<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Rapid Pair — Code or QR (lazy Firebase)</title>
<style>
  body{margin:0;padding:16px;font:15px/1.45 system-ui,Segoe UI,Roboto;background:#f7f7f8;color:#222}
  h1{margin:0 0 12px;font-size:18px}
  .row{display:grid;gap:12px;grid-template-columns:1fr}
  @media(min-width:900px){.row{grid-template-columns:1fr 1fr}}
  .card{background:#fff;border:1px solid #ddd;border-radius:12px;padding:12px;margin:10px 0}
  button{padding:8px 12px;border-radius:10px;border:1px solid #ccc;background:#f5f5f5;cursor:pointer}
  button:disabled{opacity:.55;cursor:not-allowed}
  input,textarea{padding:6px;border:1px solid #ccc;border-radius:8px}
  textarea{width:100%;height:110px;font:12px monospace}
  .status{display:inline-block;padding:2px 8px;border-radius:999px;font-size:.9rem}
  .ok{background:#e8f5e9;color:#1b5e20}
  .warn{background:#fff8e1;color:#795548}
  .bad{background:#ffebee;color:#b71c1c}
  #log{font-size:.85rem;max-height:260px;overflow:auto;white-space:pre-wrap}
  .muted{color:#666;font-size:.9rem}
  #qrWrap{max-width:520px}
  .qr-nav{display:flex;gap:8px;align-items:center}
  code.small{font-size:12px;background:#f0f0f0;padding:2px 6px;border-radius:6px}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace}
</style>
<!-- keep these local -->
<script src="qrcode.js"></script>
<script src="html5-qrcode.min.js"></script>
</head>
<body>
<h1>Rapid Pair — Code or QR <span class="muted">lazy Firebase, same payload</span></h1>

<div class="row">
  <div class="card">
    <h2>Role</h2>
    <button id="roleHost">Host</button>
    <button id="roleJoin">Joiner</button>
    <span id="roleBadge" class="status warn">no role</span>
    <div class="muted" id="tip">Ready. Pick Host/Joiner. QR is fully offline; Firebase only used if you choose typed code.</div>
  </div>
  <div class="card">
    <h2>Status</h2>
    <div>Peer: <span id="conn" class="status warn">idle</span> &nbsp; DataChannel: <span id="dc" class="status warn">-</span></div>
    <div id="log"></div>
  </div>
</div>

<div class="row">
  <div class="card">
    <h2>Typed Code (Firestore, lazy-init)</h2>
    <div id="hostCodeBlock" style="display:none">
      <button id="btnGen4">Generate 4-digit code</button>
      <button id="btnGen6">Generate 6-digit code</button>
      <span class="muted">Code:</span> <code id="showCode" class="small mono">—</code>
      <div class="muted">Joiner can type this; same payload as QR. No Firebase work happens until you click these.</div>
      <div style="margin-top:6px"><button id="btnCancelCode">Cancel / Clear</button></div>
    </div>
    <div id="joinerCodeBlock" style="display:none">
      <label>Enter code: <input id="inpCode" inputmode="numeric" class="mono" maxlength="6" style="width:10ch"/></label>
      <button id="btnUseCode">Use Code</button>
    </div>
  </div>

  <div class="card">
    <h2>QR (same payload, offline)</h2>
    <div class="row">
      <div class="card">
        <h3>Host → show QR</h3>
        <button id="qrMake" disabled>Generate QR</button>
        <button id="qrTrouble" disabled>⚠ Trouble scanning? (chunk ≤4 v4)</button>
        <div id="qrWrap" style="margin-top:8px"></div>
        <div id="qrNav" class="qr-nav" style="display:none;">
          <button id="qrPrev">◀ Prev</button>
          <span id="qrIndex"></span>
          <button id="qrNext">Next ▶</button>
        </div>
      </div>
      <div class="card">
        <h3>Joiner → scan / paste</h3>
        <button id="scanStart" disabled>Start Camera Scan</button>
        <button id="scanStop" disabled>Stop</button>
        <div id="reader" style="width:320px;max-width:100%;"></div>
        <textarea id="qrPaste" placeholder="Paste scanned text…"></textarea>
        <button id="qrApply" disabled>Apply</button>
        <div id="qrProgress" class="muted" style="margin-top:6px"></div>
      </div>
    </div>
  </div>
</div>

<div class="card">
  <h2>TURN (optional)</h2>
  <div class="muted">Only used if direct fails; doesn’t affect QR/code exchange.</div>
  <label>TURN URL: <input id="turnUrl" placeholder="turn:host:port (optional)" style="width:22ch"/></label>
  <label> Username: <input id="turnUser" class="mono" style="width:18ch"/></label>
  <label> Credential: <input id="turnPass" class="mono" style="width:18ch"/></label>
</div>

<div class="card">
  <h2>Actions</h2>
  <button id="btnBeep" disabled>Beep</button>
  <button id="btnChirp" disabled>Chirp</button>
  <button id="btnPing" disabled>Ping</button>
</div>

<script type="module">
/* ---------- UI helpers ---------- */
const $ = s => document.querySelector(s);
const logEl = $('#log');
function log(...a){ const t=a.join(' '); console.log('[LOG]', t); logEl.textContent+=t+"\n"; logEl.scrollTop=logEl.scrollHeight; }
function badge(el,t,c){ el.textContent=t; el.className='status '+c; }

/* Base64url helpers */
function b64uFromU8(u8){
  let bin=''; for(let i=0;i<u8.length;i++) bin+=String.fromCharCode(u8[i]);
  const b64 = btoa(bin); let out='';
  for(let i=0;i<b64.length;i++){ const ch=b64[i];
    if(ch==='+') out+='-'; else if(ch==='/') out+='_'; else if(ch==='='){} else out+=ch;
  } return out;
}
function u8FromB64u(s){
  let b64=''; for(let i=0;i<s.length;i++){ const ch=s[i];
    if(ch==='-') b64+='+'; else if(ch==='_') b64+='/'; else b64+=ch;
  } while(b64.length%4) b64+='=';
  const bin=atob(b64); const u8=new Uint8Array(bin.length);
  for(let i=0;i<bin.length;i++) u8[i]=bin.charCodeAt(i); return u8;
}

/* deflate/inflate (fallback to plain) */
async function deflateStr(str){
  if('CompressionStream' in window){
    const cs=new CompressionStream('deflate-raw');
    const ab = await new Response(new Blob([str]).stream().pipeThrough(cs)).arrayBuffer();
    return new Uint8Array(ab);
  } else {
    return new TextEncoder().encode(str);
  }
}
async function inflateStr(u8){
  if('DecompressionStream' in window){
    const ds=new DecompressionStream('deflate-raw');
    const ab = await new Response(new Blob([u8]).stream().pipeThrough(ds)).arrayBuffer();
    return new TextDecoder().decode(ab);
  } else {
    return new TextDecoder().decode(u8);
  }
}

/* ---------- WebRTC ---------- */
let pc=null, dc=null, role=null;
function newPC(){
  const iceServers=[{urls:'stun:stun.l.google.com:19302'}];
  const tURL=$('#turnUrl').value.trim(), tU=$('#turnUser').value.trim(), tP=$('#turnPass').value.trim();
  if(tURL){ iceServers.push(tU||tP ? {urls:tURL, username:tU, credential:tP} : {urls:tURL}); }
  const cfg={iceServers, iceCandidatePoolSize:2};
  const p=new RTCPeerConnection(cfg);
  p.onicegatheringstatechange=()=>log('gathering:', p.iceGatheringState);
  p.oniceconnectionstatechange=()=>log('ice:', p.iceConnectionState);
  p.onsignalingstatechange=()=>log('signal:', p.signalingState);
  p.onconnectionstatechange=()=>{
    const s=p.connectionState; badge($('#conn'),s, s==='connected'?'ok':(s==='failed'||s==='disconnected'?'bad':'warn'));
    const up=s==='connected';
    ['#btnBeep','#btnChirp','#btnPing'].forEach(id=>$(id).disabled=!up);
  };
  p.ondatachannel=e=>{ dc=e.channel; attachDC(); };
  return p;
}
function attachDC(){
  if(!dc) return;
  badge($('#dc'), dc.readyState, dc.readyState==='open'?'ok':'warn');
  dc.onopen = ()=>badge($('#dc'),'open','ok');
  dc.onclose= ()=>badge($('#dc'),'closed','bad');
  dc.onmessage=e=>log('RX', e.data);
}
function send(m){ if(dc&&dc.readyState==='open') dc.send(m); }
$('#btnBeep').onclick = ()=>send('BEEP');
$('#btnChirp').onclick= ()=>send('CHIRP');
$('#btnPing').onclick = ()=>send('PING');

/* Tiny SDP payload (QR & Code share this) */
const PAY_VER='T1';
async function makeOfferPacked(){
  pc?.close(); pc=newPC();
  if(role==='host'){ dc=pc.createDataChannel('x'); attachDC(); }
  await pc.setLocalDescription(await pc.createOffer());
  if(pc.iceGatheringState!=='complete'){
    await new Promise(r=>pc.addEventListener('icegatheringstatechange',()=>pc.iceGatheringState==='complete'&&r()));
  }
  const tiny={v:PAY_VER,r:role,t:'offer',s:pc.localDescription.sdp};
  return b64uFromU8(await deflateStr(JSON.stringify(tiny)));
}
async function makeAnswerPacked(remotePacked){
  if(!pc) pc=newPC();
  const json = await inflateStr(u8FromB64u(remotePacked));
  const o = JSON.parse(json);
  if(o.t!=='offer') throw new Error('Expected offer');
  await pc.setRemoteDescription({type:'offer', sdp:o.s});
  await pc.setLocalDescription(await pc.createAnswer());
  if(pc.iceGatheringState!=='complete'){
    await new Promise(r=>pc.addEventListener('icegatheringstatechange',()=>pc.iceGatheringState==='complete'&&r()));
  }
  const tiny={v:PAY_VER,r:role,t:'answer',s:pc.localDescription.sdp};
  return b64uFromU8(await deflateStr(JSON.stringify(tiny)));
}
async function applyAnswerPacked(packed){
  const json=await inflateStr(u8FromB64u(packed));
  const o=JSON.parse(json);
  if(o.t!=='answer') throw new Error('Expected answer');
  await pc.setRemoteDescription({type:'answer', sdp:o.s});
  log('Answer applied; connecting…');
}

/* ---------- Role selection ---------- */
function setRole(r){
  role=r; badge($('#roleBadge'), r==='host'?'Host':'Joiner', 'ok');
  $('#hostCodeBlock').style.display = (r==='host')?'block':'none';
  $('#joinerCodeBlock').style.display= (r==='join')?'block':'none';
  $('#qrMake').disabled   = (r!=='host');
  $('#qrTrouble').disabled= (r!=='host');
  $('#scanStart').disabled= (r!=='join');
  $('#scanStop').disabled = (r!=='join');
  $('#qrApply').disabled  = (r!=='join');
  log('Role set to', r);
}
$('#roleHost').onclick=()=>setRole('host');
$('#roleJoin').onclick=()=>setRole('join');

/* ---------- QR path (no Firebase) ---------- */
const QR_PREFIX='QP1|';
let densePacked='', chunks=[], idx=0, multi=false;

function renderQR(txt, type /* auto|v4 */, label=''){
  const qr = (type==='v4') ? qrcode(4,'L') : qrcode(0,'L');
  qr.addData(txt); qr.make();
  const svg = qr.createSvgTag(6);
  $('#qrWrap').innerHTML = svg + (label?`<div class="muted mono">Part ${label}</div>`:'');
}
function chunkify(txt){
  // try ≤4 v4 parts, ~580 chars per chunk (v4 limit ≈640)
  const MAX=4, LEN=580;
  let arr=[]; for(let i=0;i<txt.length;i+=LEN) arr.push(txt.slice(i,i+LEN));
  if(arr.length<=MAX) return arr;
  // if still too big, we chunk the raw payload (without prefix on mid parts)
  const raw = txt.startsWith(QR_PREFIX) ? txt.slice(QR_PREFIX.length) : txt;
  arr=[]; for(let i=0;i<raw.length;i+=LEN) arr.push(raw.slice(i,i+LEN));
  return arr;
}
function showChunk(){
  const total=chunks.length, part=chunks[idx];
  const label=`${idx+1}/${total}`;
  const text=(idx===0 && !part.startsWith(QR_PREFIX)) ? (QR_PREFIX+part) : part;
  try{ renderQR(text,'v4',label); $('#qrIndex').textContent=label; }
  catch(e){ log('Chunk render error:', e.message||e); }
}
$('#qrPrev').onclick = ()=>{ if(!multi) return; idx=(idx-1+chunks.length)%chunks.length; showChunk(); };
$('#qrNext').onclick = ()=>{ if(!multi) return; idx=(idx+1)%chunks.length; showChunk(); };

$('#qrMake').onclick = async ()=>{
  if(role!=='host'){ alert('Host only'); return; }
  try{
    densePacked = await makeOfferPacked();
    const txt = QR_PREFIX + densePacked;
    renderQR(txt,'auto',''); multi=false; $('#qrNav').style.display='none';
    $('#qrTrouble').disabled=false;
    log(`Dense QR shown (auto). Length: ${txt.length}`);
  }catch(e){ log('QR make ERR', e.message||e); }
};
$('#qrTrouble').onclick = ()=>{
  if(!densePacked){ alert('Generate QR first.'); return; }
  const txt = QR_PREFIX + densePacked;
  chunks = chunkify(txt); multi=true; idx=0; showChunk(); $('#qrNav').style.display='flex';
};

let scanner=null;
function stopScan(){ scanner?.stop().then(()=>scanner.clear()).catch(()=>{}); scanner=null; }
function absorb(text){
  try{
    const payload = text.startsWith(QR_PREFIX) ? text.slice(QR_PREFIX.length) : text;
    if(role!=='join'){ alert('Joiner only'); return; }
    makeAnswerPacked(payload).then(ans=>{
      log('QR: built answer; hand this to Host via code or second QR if needed.');
      // If you want QR round-trip, you could render ans here for Host to scan.
    }).catch(e=>log('applyPacked ERR', e.message||e));
  }catch(e){ log('absorb ERR', e.message||e); }
}
$('#scanStart').onclick=()=>{
  try{
    scanner = new Html5Qrcode("reader");
    scanner.start({facingMode:"environment"}, {fps:10, qrbox:240},
      txt => { absorb(txt); $('#qrProgress').textContent='Scanned.'; stopScan(); },
      _err => {}
    ).catch(err=>log('scan ERR', err));
  }catch(e){ log('scanner init ERR', e.message||e); }
};
$('#scanStop').onclick=()=>stopScan();
$('#qrApply').onclick = ()=>{ const t=$('#qrPaste').value.trim(); if(t){ absorb(t); $('#qrPaste').value=''; } };

/* ---------- Lazy Firebase for code path ---------- */
const fb = {
  app:null, auth:null, db:null,
  F:null, // firestore fns
  ready:false, initPromise:null
};
async function ensureFirebase(){
  if(fb.ready) return;
  if(fb.initPromise) return fb.initPromise;
  fb.initPromise = (async ()=>{
    // dynamic imports ONLY when needed
    const { initializeApp } = await import('https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js');
    const { getAuth, signInAnonymously } = await import('https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js');
    const {
      initializeFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, onSnapshot, serverTimestamp
    } = await import('https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js');

    fb.app = initializeApp({
      apiKey:"AIzaSyBZhqD0RE0miHDHhhlDZerGIsD0S5oy4Yw",
      authDomain:"ucpairing.firebaseapp.com",
      projectId:"ucpairing"
    });
    fb.auth = getAuth(fb.app);
    fb.db   = initializeFirestore(fb.app,{experimentalAutoDetectLongPolling:true});
    fb.F    = { doc, getDoc, setDoc, updateDoc, deleteDoc, onSnapshot, serverTimestamp };

    // anonymous auth (only now!)
    await signInAnonymously(fb.auth);
    fb.ready=true;
    log('Firebase ready (lazy init + anon auth).');
  })().catch(err=>{
    fb.initPromise=null; fb.ready=false;
    log('Firebase init/auth ERR', err.code||err.message);
    throw err;
  });
  return fb.initPromise;
}
function pairRef(code){ return fb.F.doc(fb.db,'pairs', code); }
async function reserveCode(len){
  // Quick attempt loop to avoid collisions
  for(let i=0;i<40;i++){
    const code = (''+Math.floor(Math.random()*Math.pow(10,len))).padStart(len,'0');
    const ref = pairRef(code);
    const snap = await fb.F.getDoc(ref);
    if(!snap.exists()) return code;
  }
  return null;
}

/* Host: generate 4/6 digit */
let codeRef=null, codeUnsub=null;
async function hostGenCode(len){
  if(role!=='host'){ alert('Host only'); return; }
  try{
    const packed = await makeOfferPacked();
    await ensureFirebase(); // only now
    let code = await reserveCode(len);
    if(!code && len===4){ code = await reserveCode(6); }
    if(!code){ alert('No free codes; try again.'); return; }
    $('#showCode').textContent=code;
    codeRef = pairRef(code);
    await fb.F.setDoc(codeRef, { from:'host', offer: packed, ts: fb.F.serverTimestamp() }, {merge:true});
    log(`Host wrote offer to /pairs/${code}. Waiting for answer…`);
    codeUnsub?.(); // safety
    codeUnsub = fb.F.onSnapshot(codeRef, async snap=>{
      const d=snap.data()||{};
      if(d.answer){
        try{
          const json = await inflateStr(u8FromB64u(d.answer));
          const obj = JSON.parse(json);
          await pc.setRemoteDescription({type:'answer', sdp: obj.s});
          log('Host: applied answer from code; connecting…');
          codeUnsub && codeUnsub();
        }catch(e){ log('Apply answer ERR', e.message||e); }
      }
    }, err=>log('onSnapshot ERR', err.code||err.message));
  }catch(e){
    log('Host code ERR', e.code||e.message||e);
    alert('Code path failed: '+(e.code||e.message||e));
  }
}
$('#btnGen4').onclick = ()=>hostGenCode(4);
$('#btnGen6').onclick = ()=>hostGenCode(6);
$('#btnCancelCode').onclick = async ()=>{
  try{ codeUnsub && codeUnsub(); }catch{}
  codeUnsub=null;
  if(codeRef){ try{ await ensureFirebase(); await fb.F.deleteDoc(codeRef); }catch{} }
  codeRef=null; $('#showCode').textContent='—';
  log('Host: code cancelled/cleared.');
};

/* Joiner: use code */
$('#btnUseCode').onclick = async ()=>{
  if(role!=='join'){ alert('Joiner only'); return; }
  const code = $('#inpCode').value.trim();
  if(!code) return;
  try{
    await ensureFirebase(); // only now
    const ref = pairRef(code);
    const snap = await fb.F.getDoc(ref);
    if(!snap.exists()){ alert('Code not found.'); return; }
    const d=snap.data()||{};
    if(!d.offer){ alert('Offer not ready yet.'); return; }
    const answerPacked = await makeAnswerPacked(d.offer);
    await fb.F.updateDoc(ref, { answer: answerPacked, ts: fb.F.serverTimestamp() });
    log('Joiner: wrote answer via code; Host should connect.');
  }catch(e){
    log('Joiner code ERR', e.code||e.message||e);
    alert('Joiner code failed: '+(e.code||e.message||e));
  }
};

/* ---------- Boot ---------- */
badge($('#conn'),'idle','warn'); badge($('#dc'),'-','warn');
log('Ready. Pick Host/Joiner. QR is offline; Firebase wakes up only if you choose typed code.');
</script>
</body>
</html>