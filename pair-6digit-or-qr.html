<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Pair via 6-Digit or QR</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --gap: 10px; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; }
    header { padding: 12px 16px; border-bottom: 1px solid #eee; display:flex; justify-content:space-between; align-items:center; }
    main { padding: 16px; display:grid; gap: var(--gap); grid-template-columns: 1fr; max-width: 900px; margin: 0 auto; }
    .row { display:flex; flex-wrap:wrap; gap: var(--gap); align-items: center; }
    .col { display:flex; flex-direction:column; gap: 6px; }
    input[type="text"] { font-size: 16px; padding: 8px 10px; width: 160px; }
    button { padding: 8px 12px; font-size: 14px; border: 1px solid #ddd; border-radius: 8px; background:#fff; cursor:pointer; }
    button:disabled { opacity: .5; cursor: not-allowed; }
    .muted { color:#666; }
    #qr, #qrChunks { display:flex; gap: 16px; flex-wrap: wrap; }
    canvas { background:#fff; padding:8px; border:1px solid #eee; border-radius: 8px; }
    #reader { width: 320px; max-width: 100%; }
    details { border:1px solid #eee; border-radius:8px; padding:8px 12px; }
    summary { cursor:pointer; }
    #log { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; background:#0b1220; color:#e6edf3; padding:10px; border-radius:8px; max-height:200px; overflow:auto; white-space:pre-wrap; }
    .tag { display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border:1px solid #eee; border-radius:999px; }
    .green { color:#0a7f3f; }
    .red { color:#b32222; }
    .chip { background:#f6f7f9; border:1px solid #e5e7eb; border-radius:999px; padding:2px 8px; font-size:12px; }
  </style>
  <script src="https://unpkg.com/html5-qrcode/minified/html5-qrcode.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.1/build/qrcode.min.js"></script>
</head>
<body>
  <header>
    <strong>Pair Devices</strong>
    <span class="muted">P2P first • TURN only if needed</span>
  </header>

  <main>
    <div class="row">
      <label class="tag"><input type="radio" name="role" id="hostBtn"> Host</label>
      <label class="tag"><input type="radio" name="role" id="joinBtn"> Joiner</label>
      <span id="roleHint" class="muted"></span>
    </div>

    <div class="row">
      <div class="col">
        <label for="roomCode">6-digit code</label>
        <input id="roomCode" type="text" inputmode="numeric" pattern="[0-9]*" maxlength="6" placeholder="000000">
      </div>
      <div class="row">
        <button id="randomBtn">Random Code & Start</button>
        <button id="startBtn">Start</button>
        <button id="resetBtn">Reset</button>
      </div>
      <div class="chip">Project: <span id="proj" style="margin-left:6px">ucpairing</span></div>
    </div>

    <div class="row">
      <button id="makeQRBtn" disabled>Make & show my QR</button>
      <button id="scanQRBtn" disabled>Scan partner QR</button>
    </div>

    <div id="qr"></div>

    <details id="qrAlt" style="display:none;">
      <summary>Trouble scanning?</summary>
      <div class="muted" style="margin:8px 0">Scan these big, simple chunks in order. The Joiner will show “Got 1, 2, 4” while scanning.</div>
      <div id="qrChunks"></div>
      <div id="chunkStatus" class="muted"></div>
    </details>

    <div id="reader"></div>

    <section>
      <h3 style="margin:8px 0;">Debug</h3>
      <div id="log"></div>
      <div class="muted" style="margin-top:6px;">Tip: if both devices are on the same Uni Wi-Fi, you should see direct P2P without TURN.</div>
    </section>
  </main>

  <script type="module">
    // ---------- Utils ----------
    const $ = (sel) => document.querySelector(sel);
    const logEl = $("#log");
    function log(...args) {
      const line = args.map(a => typeof a === "string" ? a : JSON.stringify(a)).join(" ");
      logEl.textContent += line + "\\n";
      logEl.scrollTop = logEl.scrollHeight;
      console.log(...args);
    }
    function b64uFromStr(s) {
      return btoa(unescape(encodeURIComponent(s))).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
    }
    function strFromB64u(b) {
      return decodeURIComponent(escape(atob(b.replace(/-/g,'+').replace(/_/g,'/'))));
    }

    // Chunk helpers (for the 6-digit code we usually don’t need this, but we expose it to keep scans big & easy)
    function splitToChunks(str, n) {
      const size = Math.ceil(str.length / n);
      const out = [];
      for (let i=0;i<n;i++) out.push(str.slice(i*size, (i+1)*size));
      return out;
    }

    // ---------- Firebase ----------
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
    import {
      getFirestore, doc, setDoc, getDoc, onSnapshot, deleteDoc, serverTimestamp, Timestamp, updateDoc
    } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

    const firebaseConfig = { projectId: "ucpairing" };
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    log("Firebase ready. projectId=", firebaseConfig.projectId);

    // ---------- ICE / WebRTC ----------
    const iceServers = [
      { urls: "stun:stun.l.google.com:19302" },
      {
        urls: [
          "turn:openrelay.metered.ca:80",
          "turn:openrelay.metered.ca:443",
          "turns:openrelay.metered.ca:443"
        ],
        username: "openrelayproject",
        credential: "openrelayproject"
      }
    ];
    function newPC() {
      const pc = new RTCPeerConnection({
        iceServers,
        iceTransportPolicy: "all" // P2P first, TURN only if needed
      });
      pc.onicegatheringstatechange = () => log("gathering:", pc.iceGatheringState);
      pc.oniceconnectionstatechange = () => log("ice:", pc.iceConnectionState);
      pc.onsignalingstatechange = () => log("signal:", pc.signalingState);
      return pc;
    }

    // ---------- Elements & State ----------
    const hostBtn = $("#hostBtn");
    const joinBtn = $("#joinBtn");
    const roleHint = $("#roleHint");
    const codeBox = $("#roomCode");
    const randomBtn = $("#randomBtn");
    const startBtn = $("#startBtn");
    const resetBtn = $("#resetBtn");
    const makeQRBtn = $("#makeQRBtn");
    const scanQRBtn = $("#scanQRBtn");
    const qrDiv = $("#qr");
    const qrAlt = $("#qrAlt");
    const qrChunksDiv = $("#qrChunks");
    const chunkStatus = $("#chunkStatus");
    const readerDiv = $("#reader");

    let role = null;
    let pc = null;
    let roomDoc = null;
    let stopQRScan = null;

    // ---------- UI logic ----------
    function setRole(newRole) {
      role = newRole;
      if (role === "host") {
        makeQRBtn.disabled = false;
        scanQRBtn.disabled = true;
        roleHint.textContent = "Host: show your code/QR; Joiner scans or types the code.";
      } else if (role === "joiner") {
        makeQRBtn.disabled = true;
        scanQRBtn.disabled = false;
        roleHint.textContent = "Joiner: scan Host’s QR or type the 6-digit code.";
      } else {
        roleHint.textContent = "";
      }
    }

    hostBtn.onclick = () => setRole("host");
    joinBtn.onclick = () => setRole("joiner");

    codeBox.addEventListener("input", () => {
      // If the user edits the box, keep Random separate and allow manual Start
      randomBtn.textContent = "Random Code & Start";
    });

    randomBtn.onclick = async () => {
      const code = String(Math.floor(100000 + Math.random() * 900000));
      codeBox.value = code;
      randomBtn.textContent = "Random picked ✓";
      await startCloud(code);
    };

    startBtn.onclick = async () => {
      const code = codeBox.value.trim();
      if (!/^[0-9]{6}$/.test(code)) return alert("Enter a valid 6-digit code.");
      await startCloud(code);
    };

    resetBtn.onclick = async () => {
      try {
        if (roomDoc) await deleteDoc(roomDoc);
      } catch (e) {
        // ignore delete failures; it might not exist or rules may block
      }
      if (pc) pc.close();
      window.location.reload();
    };

    // QR: single fat code
    makeQRBtn.onclick = () => {
      if (!codeBox.value.trim()) return alert("Pick a 6-digit code first.");
      qrDiv.innerHTML = "";
      qrAlt.style.display = "none";

      // Big & simple QR for the 6-digit code
      QRCode.toCanvas(codeBox.value.trim(), { width: 280, errorCorrectionLevel: "L" }, (err, canvas) => {
        if (!err) qrDiv.appendChild(canvas);
      });

      // Also prepare the 4-chunk option (same content, just split with labels for even larger modules)
      const payload = codeBox.value.trim();               // keep it short & robust
      const chunks = splitToChunks(payload, 4);
      qrChunksDiv.innerHTML = "";
      chunks.forEach((chunk, i) => {
        const wrap = document.createElement("div");
        const label = document.createElement("div");
        label.className = "muted";
        label.textContent = `#${i+1}`;
        wrap.appendChild(label);
        const ctn = document.createElement("div");
        QRCode.toCanvas(`${i+1}:${chunks.length}:${chunk}`, { width: 260, errorCorrectionLevel: "L" }, (err, canvas) => {
          if (!err) ctn.appendChild(canvas);
        });
        wrap.appendChild(ctn);
        qrChunksDiv.appendChild(wrap);
      });
      chunkStatus.textContent = "Waiting for scans…";
      qrAlt.style.display = "";
    };

    // QR scan (single or chunked)
    scanQRBtn.onclick = () => startScanner();

    async function startScanner() {
      readerDiv.innerHTML = "";
      const scanner = new Html5Qrcode("reader");
      const got = new Set();  // which chunk numbers we’ve seen
      let reconstructed = "";

      const onDecoded = async (text) => {
        // Accept either single code OR chunk “i:n:chunk”
        const m = text.match(/^(\d+):(\d+):(.*)$/);
        if (m) {
          const i = parseInt(m[1], 10);
          const n = parseInt(m[2], 10);
          got.add(i);
          chunkStatus.textContent = "Got " + [...got].sort((a,b)=>a-b).join(", ");
          // We can be ultra-simple: store pieces by index
          if (!window._chunks) window._chunks = {};
          window._chunks[i] = m[3];
          if (got.size === n) {
            reconstructed = "";
            for (let k=1;k<=n;k++) reconstructed += window._chunks[k] || "";
            await finalizeScan(reconstructed);
            await scanner.stop();
          }
        } else {
          // single code path
          await finalizeScan(text.trim());
          await scanner.stop();
        }
      };

      try {
        await scanner.start({ facingMode: "environment" }, { fps: 10, qrbox: 280 }, onDecoded);
        stopQRScan = () => scanner.stop();
      } catch (e) {
        log("QR start error:", e.message || e);
        alert("Couldn’t start camera for scanning.");
      }
    }

    async function finalizeScan(code) {
      if (!/^[0-9]{6}$/.test(code)) {
        alert("Scanned content isn’t a 6-digit code. Try again.");
        return;
      }
      codeBox.value = code;
      await startCloud(code);
    }

    // ---------- Firestore signaling ----------
    async function startCloud(code) {
      // Stop scanner if it’s running
      if (stopQRScan) { try { await stopQRScan(); } catch {} }

      roomDoc = doc(db, "rooms", code);
      pc = newPC();

      // Create a data channel to make ICE connectivity “active”
      const ch = pc.createDataChannel("data");
      ch.onopen = () => log("data: open");
      ch.onclose = () => log("data: close");
      ch.onerror = (e) => log("data: error", e?.message || e);

      // Host flow
      if (role === "host") {
        try {
          const offer = await pc.createOffer({ iceRestart: false });
          await pc.setLocalDescription(offer);

          // Write with a server-set creation time and a client TTL that satisfies your rule
          const ttlMillis = 60 * 60 * 1000; // 1h
          const expiresAt = Timestamp.fromMillis(Date.now() + ttlMillis);

          await setDoc(roomDoc, {
            offer: { type: offer.type, sdp: offer.sdp },
            type: "offer",
            createdAt: serverTimestamp(),
            expiresAt
          });

          log("Cloud: offer written");

          onSnapshot(roomDoc, async (snap) => {
            const d = snap.data();
            if (!d) return;
            if (d.answer && !pc.currentRemoteDescription) {
              try {
                await pc.setRemoteDescription(d.answer);
                log("Cloud: got answer");
              } catch (e) {
                log("ERR setRemoteDescription:", e?.message || e);
              }
            }
          });
        } catch (e) {
          handleFsError("Host write/subscribe", e);
        }

      // Joiner flow
      } else if (role === "joiner") {
        try {
          const snap = await getDoc(roomDoc);
          const d = snap.data();
          if (!d?.offer) {
            alert("No offer in this room yet. Ask the Host to start.");
            return;
          }
          await pc.setRemoteDescription(d.offer);

          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);

          const ttlMillis = 60 * 60 * 1000; // 1h
          const expiresAt = Timestamp.fromMillis(Date.now() + ttlMillis);

          // Preserve existing fields, add answer
          await setDoc(roomDoc, {
            ...d,
            answer: { type: answer.type, sdp: answer.sdp },
            type: "answer",
            expiresAt
          });

          log("Cloud: answer written");
        } catch (e) {
          handleFsError("Joiner read/write", e);
        }
      } else {
        alert("Pick Host or Joiner first.");
      }
    }

    function handleFsError(ctx, e) {
      const msg = e?.message || String(e);
      log(`Firestore error (${ctx}):`, msg);
      if (/permission/i.test(msg)) {
        alert("Firestore says “Missing or insufficient permissions.”\n\nLikely causes:\n• The 6-digit code doc doesn’t meet the rules (e.g., missing/late expiresAt)\n• Clock skew vs your TTL rule\n• Reading before Host created the doc\n\nI’ve switched to using Firestore Timestamps and clearer order. Try again now.");
      } else {
        alert(`Firestore error (${ctx}): ${msg}`);
      }
    }
  </script>
</body>
</html>
