<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Rapid Pair — QR-only (LAN, first host candidate)</title>
<style>
  body{margin:0;padding:16px;font:15px/1.4 system-ui;background:#f7f7f8;color:#222}
  h1{margin:0 0 12px;font-size:18px}
  .row{display:grid;gap:12px;grid-template-columns:1fr}
  @media(min-width:900px){.row{grid-template-columns:1fr 1fr}}
  .card{background:#fff;border:1px solid #ddd;border-radius:12px;padding:12px;margin:10px 0}
  button{padding:8px 12px;border-radius:10px;border:1px solid #ccc;background:#f5f5f5;cursor:pointer}
  button:disabled{opacity:.55;cursor:not-allowed}
  input,textarea{padding:6px;border:1px solid #ccc;border-radius:8px}
  textarea{width:100%;height:110px;font:12px monospace}
  .status{display:inline-block;padding:2px 8px;border-radius:999px;font-size:.9rem}
  .ok{background:#e8f5e9;color:#1b5e20} .warn{background:#fff8e1;color:#795548} .bad{background:#ffebee;color:#b71c1c}
  #log{font-size:.85rem;max-height:220px;overflow:auto;white-space:pre-wrap}
  #qrWrap{max-width:460px}
  .qr-nav{display:flex;gap:8px;align-items:center}
  #ver{color:#666;font-size:.8rem}
  .muted{color:#666;font-size:.9rem}
</style>
<!-- Keep these three files next to this HTML (no Firebase needed) -->
<script src="qrcode.js"></script>
<script src="pako.min.js"></script>
<script src="html5-qrcode.min.js"></script>
</head>
<body>
<h1>Rapid Pair — QR-only (LAN) <span id="ver">v0.3</span></h1>

<div class="row">
  <div class="card">
    <h2>Role</h2>
    <button id="roleHost">Host</button>
    <button id="roleJoin">Joiner</button>
    <span id="roleBadge" class="status warn">no role</span>
    <div class="muted" style="margin-top:6px">
      Flow: Host shows QR → Joiner scans & shows reply → Host scans reply. No internet needed.
    </div>
  </div>
  <div class="card">
    <h2>Status</h2>
    <div>Peer: <span id="conn" class="status warn">idle</span> &nbsp; DataChannel: <span id="dc" class="status warn">-</span></div>
    <div id="log"></div>
  </div>
</div>

<div class="card">
  <h2>QR (offline, same LAN)</h2>
  <div class="row">
    <div class="card">
      <h3>Make & show my QR</h3>
      <button id="qrMake" disabled>⚡ Create my QR (instant, first LAN cand)</button>
      <button id="qrTrouble" style="display:none;">⚠ Trouble scanning? (4 fat codes)</button>
      <label style="display:block;margin-top:6px"><input type="checkbox" id="robustECC"> Robust (ECC=M)</label>
      <div id="qrWrap" style="margin-top:8px"></div>
      <div id="qrNav" class="qr-nav" style="display:none;">
        <button id="qrPrev">◀ Prev</button>
        <span id="qrIndex"></span>
        <button id="qrNext">Next ▶</button>
      </div>
    </div>
    <div class="card">
      <h3>Scan partner QR</h3>
      <button id="scanStart" disabled>Start Camera Scan</button>
      <button id="scanStop" disabled>Stop</button>
      <div id="reader" style="width:320px;max-width:100%;"></div>
      <textarea id="qrPaste" placeholder="Paste scanned text…"></textarea>
      <button id="qrApply" disabled>Apply</button>
      <div id="qrProgress" class="muted" style="margin-top:6px"></div>
    </div>
  </div>
</div>

<div class="card">
  <h2>Actions (after connect)</h2>
  <button id="btnBeep" disabled>Beep</button>
  <button id="btnChirp" disabled>Chirp</button>
  <button id="btnPing" disabled>Ping</button>
</div>

<script>
/* ========== UI helpers ========== */
const $=s=>document.querySelector(s), logEl=$('#log');
function log(...a){logEl.textContent+=a.join(' ')+"\n";logEl.scrollTop=logEl.scrollHeight;}
function badge(el,t,c){el.textContent=t;el.className='status '+c;}
function b64url(u8){let bin='';for(let i=0;i<u8.length;i++)bin+=String.fromCharCode(u8[i]);const b64=btoa(bin);let out='';for(let i=0;i<b64.length;i++){const ch=b64[i];if(ch==='+')out+='-'; else if(ch==='/')out+='_'; else if(ch==='='){} else out+=ch;} return out;}
function unb64url(s){let b64='';for(let i=0;i<s.length;i++){const ch=s[i]; if(ch==='-')b64+='+'; else if(ch==='_')b64+='/'; else b64+=ch;} while(b64.length%4)b64+='='; const bin=atob(b64); const u8=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++)u8[i]=bin.charCodeAt(i); return u8;}
function pack(o){ return b64url(pako.deflate(JSON.stringify(o))); }
function unpack(s){ return JSON.parse(pako.inflate(unb64url(s), {to:'string'})); }

/* ========== Role UI ========== */
let role=null;
function setRole(r){
  role=r; badge($('#roleBadge'), r==='host'?'Host':'Joiner','ok');
  const canScan = true; // both sides may need to scan at some point
  $('#qrMake').disabled=false;
  $('#scanStart').disabled=!canScan; $('#scanStop').disabled=!canScan; $('#qrApply').disabled=!canScan;
  log('Ready as', r.toUpperCase(), '— Flow is Host→Joiner→Host (two QRs total).');
}
$('#roleHost').onclick=()=>setRole('host');
$('#roleJoin').onclick=()=>setRole('join');

/* ========== WebRTC (no STUN/TURN; LAN host candidates only) ========== */
let pc,dc;
function newPC(){
  const cfg={iceServers:[], iceTransportPolicy:'all'}; // no STUN -> only host candidates
  const p=new RTCPeerConnection(cfg);
  p.onicegatheringstatechange=()=>log('gathering:', p.iceGatheringState);
  p.oniceconnectionstatechange=()=>log('ice:', p.iceConnectionState);
  p.onsignalingstatechange = ()=>log('signal:', p.signalingState);
  p.onconnectionstatechange=()=>{
    const s=p.connectionState; badge($('#conn'),s, s==='connected'?'ok':(s==='failed'||s==='disconnected'?'bad':'warn'));
    const up=s==='connected'; ['#btnBeep','#btnChirp','#btnPing'].forEach(id=>$(id).disabled=!up);
  };
  p.ondatachannel = e=>{ dc=e.channel; attachDC(); };
  return p;
}
function attachDC(){
  badge($('#dc'),dc.readyState, dc.readyState==='open'?'ok':'warn');
  dc.onopen = ()=>badge($('#dc'),'open','ok');
  dc.onclose= ()=>badge($('#dc'),'closed','bad');
  dc.onmessage=e=>log('RX', e.data);
}
function send(m){ if(dc&&dc.readyState==='open') dc.send(m); }
$('#btnBeep').onclick=()=>send('BEEP');
$('#btnChirp').onclick=()=>send('CHIRP');
$('#btnPing').onclick =()=>send('PING');

/* Extract only the first "typ host" candidate from an SDP string */
function firstHostCandidateLines(sdp){
  const lines = sdp.split(/\r?\n/);
  const cands = lines.filter(l=>l.startsWith('a=candidate:') && / typ host(\s|$)/.test(l));
  return cands.length? [cands[0]] : [];
}
/* Build a minimal SDP by keeping core lines + first host candidate(s) */
function minimizeSDPForLAN(fullSDP){
  const keepPrefixes = new Set([
    'v=','o=','s=','t=',
    'a=group:','a=extmap-allow-mixed','a=msid-semantic:',
    'm=application','c=IN IP4','a=ice-ufrag:','a=ice-pwd:',
    'a=fingerprint:','a=setup:','a=mid:','a=sctp-port:','a=max-message-size:'
  ]);
  const lines = fullSDP.split(/\r?\n/).filter(Boolean);
  const base = lines.filter(l=>{
    for(const k of keepPrefixes){ if(l.startsWith(k)) return true; }
    return false;
  });
  const host1 = firstHostCandidateLines(fullSDP);
  // Note: include only 1 host candidate for instant QR
  return base.concat(host1).join('\r\n')+'\r\n';
}

/* ========== QR pack/unpack (with optional chunking) ========== */
const QR_PREFIX='RP1|'; // version tag
const CHUNK_COUNT=4;
const SCALE_SINGLE=3, SCALE_CHUNK=6;

function split4(s){ const sz=Math.ceil(s.length/CHUNK_COUNT); return Array.from({length:CHUNK_COUNT},(_,i)=>s.slice(i*sz,(i+1)*sz)); }
function renderQR(txt,scale,ecc){ const q=qrcode(0,ecc); q.addData(txt); q.make(); return q.createSvgTag(scale); }

let qrPacked='', qrChunks=[], qrMode='single', qrIdx=0;

function showQR(){
  const ecc = $('#robustECC').checked ? 'M' : 'L';
  if(qrMode==='single'){
    $('#qrWrap').innerHTML = renderQR(qrPacked, SCALE_SINGLE, ecc);
    $('#qrNav').style.display='none';
  }else{
    const payload = `${QR_PREFIX}${qrChunks.length}|${qrIdx+1}|${qrChunks[qrIdx]}`;
    $('#qrWrap').innerHTML = renderQR(payload, SCALE_CHUNK, ecc);
    $('#qrIndex').textContent = `${qrIdx+1}/${qrChunks.length}`;
    $('#qrNav').style.display='flex';
  }
}
$('#qrPrev').onclick=()=>{ qrIdx=(qrIdx-1+qrChunks.length)%qrChunks.length; showQR(); };
$('#qrNext').onclick=()=>{ qrIdx=(qrIdx+1)%qrChunks.length; showQR(); };
$('#qrTrouble').onclick=()=>{ qrChunks=split4(qrPacked); qrIdx=0; qrMode='multi'; showQR(); };

/* ========== Flow ========== */
/*
  Host:
    - pc = newPC(); dc = createDataChannel()
    - createOffer(); setLocalDescription(offer)
    - As soon as first host candidate appears (or immediately if already present):
        build minimal SDP (first host cand only) -> QR
    - Then scan Joiner reply; setRemoteDescription(answer) -> connect
  Joiner:
    - Scan Host QR -> setRemoteDescription(offer)
    - createAnswer(); setLocalDescription(answer)
    - Wait for first host candidate (quick), then show reply QR (minimized)
    - Host scans reply -> connect
*/

let gotFirstHostCand = false;
let pendingMakeResolve = null;

async function makeMyQR(){
  if(!role){ alert('Pick role first'); return; }
  $('#qrTrouble').style.display='none'; qrMode='single';

  if(!pc){
    pc = newPC();
    if(role==='host'){ dc = pc.createDataChannel('x'); attachDC(); }
    pc.onicecandidate = (e)=>{
      if(e.candidate && / typ host(\s|$)/.test(e.candidate.candidate)){
        if(!gotFirstHostCand){ gotFirstHostCand=true; if(pendingMakeResolve){ pendingMakeResolve(); } }
      }
    };
  }

  if(role==='host' && pc.signalingState==='stable'){
    await pc.setLocalDescription(await pc.createOffer());
    log('signal:', pc.signalingState);
  }else if(role==='join' && pc.signalingState==='have-remote-offer'){
    // already have remote (from earlier scan), just answer
    await pc.setLocalDescription(await pc.createAnswer());
    log('signal:', pc.signalingState);
  }else if(role==='join' && pc.signalingState==='stable'){
    // If joiner clicks before scanning host QR
    alert('Joiner needs to scan Host QR first.');
    return;
  }

  // Wait briefly for first host cand, but don't block forever (instant feel)
  gotFirstHostCand = false;
  const waitFirst = new Promise(res=>pendingMakeResolve=res);
  const timeout = new Promise(res=>setTimeout(res, 250)); // 250ms cap
  await Promise.race([waitFirst, timeout]);

  const ld = pc.localDescription;
  const sdpMin = minimizeSDPForLAN(ld.sdp);
  const payload = { t:'webrtc-qr1', role, sdp:{type:ld.type, sdp:sdpMin}, ts:Date.now() };
  qrPacked = pack(payload);
  showQR();
  $('#qrTrouble').style.display='inline';
  log('QR ready (', role, ') — first host cand only.');
}

$('#qrMake').onclick = ()=>makeMyQR();

/* Scanner + assembly */
let asm={total:0, got:new Set(), parts:[]};
function resetAsm(){ asm={total:0,got:new Set(),parts:[]}; $('#qrProgress').textContent=''; }
function absorb(text){
  if(text.startsWith(QR_PREFIX)){
    const rest=text.slice(QR_PREFIX.length);
    const p1=rest.indexOf('|'), p2=rest.indexOf('|',p1+1);
    if(p1<0||p2<0) return;
    const total=+rest.slice(0,p1), index=+rest.slice(p1+1,p2), data=rest.slice(p2+1);
    if(!asm.total){ asm.total=total; asm.parts=Array(total).fill(''); }
    asm.got.add(index); asm.parts[index-1]=data;
    $('#qrProgress').textContent = `Got parts: ${[...asm.got].sort().join(', ')} / ${asm.total}`;
    if(asm.got.size===asm.total){
      const packed=asm.parts.join('');
      resetAsm(); applyPacked(packed);
    }
  } else {
    applyPacked(text);
  }
}

async function applyPacked(packed){
  try{
    const obj = unpack(packed); // { t, role, sdp:{type,sdp} }
    if(obj.t!=='webrtc-qr1') { log('ERR: bad payload type'); return; }

    if(!pc) pc=newPC();

    if(role==='host' && obj.role==='join'){
      // Host receiving Joiner ANSWER
      if(!pc.currentRemoteDescription){
        await pc.setRemoteDescription(new RTCSessionDescription(obj.sdp));
        log('Host: applied answer — connecting…');
      } else {
        log('Host: duplicate answer ignored.');
      }

    } else if(role==='join' && obj.role==='host'){
      // Joiner receiving Host OFFER
      if(!pc.currentRemoteDescription){
        await pc.setRemoteDescription(new RTCSessionDescription(obj.sdp));
        log('Joiner: offer applied. Creating quick LAN answer…');
        await makeMyQR(); // this will create + show answer QR quickly
        log('Joiner: reply ready — show to Host');
      } else {
        log('Joiner: duplicate offer ignored.');
      }

    } else {
      alert('Role mismatch. One must be Host, the other Joiner.');
    }
  }catch(e){ log('ERR applyPacked', e.message||e); }
}

$('#qrApply').onclick=()=>{ const t=$('#qrPaste').value.trim(); if(t){ absorb(t); $('#qrPaste').value=''; } };

let scanner=null;
$('#scanStart').onclick=()=>{
  try{
    scanner = new Html5Qrcode("reader");
    scanner.start(
      {facingMode:"environment"},
      {fps:12, qrbox:240},
      txt => absorb(txt),
      _err => {}
    ).catch(err=>log('scan ERR', err));
  }catch(e){ log('scanner init ERR', e.message||e); }
};
$('#scanStop').onclick=()=>{ scanner?.stop().then(()=>scanner.clear()).catch(()=>{}); scanner=null; };

/* ========== Actions wiring ========== */
</script>

<script>
/* UX: enable buttons only after a role is chosen; small DC demo */
document.addEventListener('DOMContentLoaded', ()=>{
  log('Ready. Pick Host/Joiner. QR-only, instant (first host candidate).');
});
</script>
</body>
</html>
