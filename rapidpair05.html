<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Rapid Pair — TinySDP via QR (LAN, no Firebase)</title>
<style>
  :root{--fg:#222;--bg:#f7f7f8;--card:#fff;--muted:#666}
  body{margin:0;padding:16px;font:15px/1.45 system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--fg)}
  h1{margin:0 0 10px;font-size:18px}
  .row{display:grid;gap:12px;grid-template-columns:1fr}
  @media(min-width:900px){.row{grid-template-columns:1fr 1fr}}
  .card{background:var(--card);border:1px solid #ddd;border-radius:12px;padding:12px;margin:10px 0}
  button{padding:8px 12px;border-radius:10px;border:1px solid #ccc;background:#f5f5f5;cursor:pointer}
  button:disabled{opacity:.55;cursor:not-allowed}
  input,textarea{padding:6px;border:1px solid #ccc;border-radius:8px;font:inherit}
  textarea{width:100%;height:110px;font:12px/1.4 ui-monospace,Consolas,Menlo,monospace}
  .status{display:inline-block;padding:2px 8px;border-radius:999px;font-size:.9rem}
  .ok{background:#e8f5e9;color:#1b5e20}
  .warn{background:#fff8e1;color:#795548}
  .bad{background:#ffebee;color:#b71c1c}
  #log{font-size:.85rem;max-height:220px;overflow:auto;white-space:pre-wrap}
  #qrWrap svg{width:100%;height:auto;display:block}
  .qr-nav{display:flex;gap:8px;align-items:center;justify-content:center}
  .muted{color:var(--muted);font-size:.9rem}
  #reader{width:320px;max-width:100%;border:1px dashed #ccc;border-radius:10px;min-height:220px}
  .pairgrid{display:grid;gap:12px;grid-template-columns:1fr}
  @media(min-width:1000px){.pairgrid{grid-template-columns:1fr 1fr}}
  #ver{color:#666;font-size:.8rem}
</style>

<!-- Local libs (place alongside this file) -->
<script src="qrcode.js"></script>
<script src="pako.min.js"></script>
<script src="html5-qrcode.min.js"></script>
</head>
<body>
<h1>Rapid Pair — TinySDP via QR (LAN, no Firebase) <span id="ver">v0.6</span></h1>

<div class="row">
  <div class="card">
    <h2>Role</h2>
    <button id="roleHost">Host</button>
    <button id="roleJoin">Joiner</button>
    <span id="roleBadge" class="status warn">no role</span>
  </div>
  <div class="card">
    <h2>Status</h2>
    <div>Peer: <span id="conn" class="status warn">idle</span> &nbsp; DataChannel: <span id="dc" class="status warn">-</span></div>
    <div id="log"></div>
  </div>
</div>

<div class="card">
  <h2>QR exchange (offline, same LAN)</h2>
  <div class="pairgrid">
    <div class="card">
      <h3>Make & show my QR</h3>
      <button id="qrMake" disabled>Create my QR</button>
      <button id="qrTrouble" disabled>⚠ Trouble scanning? (force ≤4× v4)</button>
      <label style="display:block;margin-top:6px"><input type="checkbox" id="robustECC"> Robust (ECC=M)</label>
      <div id="qrWrap" style="margin-top:8px"></div>
      <div id="qrNav" class="qr-nav" style="display:none;">
        <button id="qrPrev">◀ Prev</button>
        <span id="qrIndex"></span>
        <button id="qrNext">Next ▶</button>
      </div>
    </div>
    <div class="card">
      <h3>Scan partner QR</h3>
      <button id="scanStart" disabled>Start Camera Scan</button>
      <button id="scanStop" disabled>Stop</button>
      <div id="reader"></div>
      <textarea id="qrPaste" placeholder="Or paste scanned text then Apply…"></textarea>
      <button id="qrApply" disabled>Apply</button>
      <div id="qrProgress" class="muted" style="margin-top:6px"></div>
    </div>
  </div>
  <div class="muted">Flow: Host shows QR → Joiner scans & shows reply QR → Host scans reply. (No internet needed.)</div>
</div>

<div class="card">
  <h2>Actions (when connected)</h2>
  <button id="btnBeep" disabled>Beep</button>
  <button id="btnChirp" disabled>Chirp</button>
  <button id="btnPing" disabled>Ping</button>
</div>

<script>
/* =================== Small logging helpers =================== */
const $ = s => document.querySelector(s);
const logEl = $('#log');
function log(...a){ const line=a.join(' '); console.log('[LOG]', line); logEl.textContent+=line+"\n"; logEl.scrollTop=logEl.scrollHeight; }
function badge(el,t,c){ el.textContent=t; el.className='status '+c; }
log('Ready. Pick Host/Joiner. For instant LAN, the single dense QR should work; click "Trouble scanning?" to force ≤4× v4 chunks.');

/* =================== Safe base64url + pack =================== */
function b64urlFromU8(u8){
  let bin=''; for(let i=0;i<u8.length;i++) bin+=String.fromCharCode(u8[i]);
  let b64=btoa(bin), out='';
  for(let i=0;i<b64.length;i++){ const ch=b64[i];
    if(ch==='+') out+='-'; else if(ch==='/') out+='_'; else if(ch==='='){} else out+=ch;
  }
  return out;
}
function u8FromB64url(s){
  let b64=''; for(let i=0;i<s.length;i++){ const ch=s[i];
    if(ch==='-') b64+='+'; else if(ch==='_') b64+='/'; else b64+=ch;
  }
  while(b64.length%4) b64+='=';
  const bin=atob(b64); const u8=new Uint8Array(bin.length);
  for(let i=0;i<bin.length;i++) u8[i]=bin.charCodeAt(i);
  return u8;
}
function pack(obj){
  const raw = new TextEncoder().encode(JSON.stringify(obj));
  const def = window.pako.deflate(raw);
  return b64urlFromU8(def);
}
function unpack(s){
  const u8 = u8FromB64url(s);
  const inf = window.pako.inflate(u8);
  return JSON.parse(new TextDecoder().decode(inf));
}

/* =================== TinySDP build/parse =================== */
/* we only carry: role ('h' or 'j'), ufrag, pwd, fp (sha-256 hex with colons), cand {ip,port} */
function extract(re, s){ const m=s.match(re); return m?m[1]:null; }
function parseFirstHostV4(sdp){
  const lines = sdp.split(/\r?\n/);
  for(const ln of lines){
    if(ln.startsWith('a=candidate:') && ln.includes(' typ host ') && ln.includes(' udp ')){
      // Candidate grammar: a=candidate:... <component> udp <prio> <ip> <port> typ host ...
      const parts = ln.trim().split(/\s+/);
      const ip = parts[4], port = parts[5];
      if(ip && port && /^\d+\.\d+\.\d+\.\d+$/.test(ip)) return {ip, port: Number(port)};
    }
  }
  return null;
}
function buildTinyFromLocal(localSdp){
  const ufrag = extract(/^a=ice-ufrag:(\S+)/m, localSdp);
  const pwd   = extract(/^a=ice-pwd:(\S+)/m,   localSdp);
  const fp    = extract(/^a=fingerprint:sha-256\s+([A-F0-9:]+)/m, localSdp);
  const cand  = parseFirstHostV4(localSdp);
  if(!ufrag || !pwd || !fp || !cand){ throw Error('tinySDP missing pieces'); }
  return { u:ufrag, p:pwd, f:fp, c:{ip:cand.ip, pt:cand.port} };
}

/* Templates to reconstruct minimal SDP for datachannel */
function sdpOfferFromTiny(t){
  // actpass, DTLS fingerprint as provided by host tiny
  return [
    'v=0',
    'o=- 0 0 IN IP4 127.0.0.1',
    's=-',
    't=0 0',
    'a=group:BUNDLE 0',
    'a=extmap-allow-mixed',
    'a=msid-semantic: WMS',
    'm=application 9 UDP/DTLS/SCTP webrtc-datachannel',
    'c=IN IP4 0.0.0.0',
    `a=ice-ufrag:${t.u}`,
    `a=ice-pwd:${t.p}`,
    'a=ice-options:trickle',
    `a=fingerprint:sha-256 ${t.f}`,
    'a=setup:actpass',
    'a=mid:0',
    'a=sctp-port:5000',
    'a=max-message-size:262144',
    // include the host's own host-v4 candidate to speed up connection
    `a=candidate:0 1 udp 2122252543 ${t.c.ip} ${t.c.pt} typ host`
  ].join('\r\n')+'\r\n';
}
function sdpAnswerFromTiny(t){
  // answer uses setup:active
  return [
    'v=0',
    'o=- 0 0 IN IP4 127.0.0.1',
    's=-',
    't=0 0',
    'a=group:BUNDLE 0',
    'a=extmap-allow-mixed',
    'a=msid-semantic: WMS',
    'm=application 9 UDP/DTLS/SCTP webrtc-datachannel',
    'c=IN IP4 0.0.0.0',
    `a=ice-ufrag:${t.u}`,
    `a=ice-pwd:${t.p}`,
    'a=ice-options:trickle',
    `a=fingerprint:sha-256 ${t.f}`,
    'a=setup:active',
    'a=mid:0',
    'a=sctp-port:5000',
    'a=max-message-size:262144',
    `a=candidate:0 1 udp 2122252543 ${t.c.ip} ${t.c.pt} typ host`
  ].join('\r\n')+'\r\n';
}

/* =================== WebRTC bits =================== */
let role = null;
let pc = null, dc = null;

function setRole(r){
  role = r;
  badge($('#roleBadge'), r==='host'?'Host':'Joiner', 'ok');
  $('#qrMake').disabled = false;
  $('#qrTrouble').disabled = true; // gets enabled after we have a dense QR
  $('#scanStart').disabled = false;
  $('#scanStop').disabled = false;
  $('#qrApply').disabled = false;
  log('Role set to', r);
}

function newPC(){
  const cfg = { iceServers: [] }; // LAN only
  pc = new RTCPeerConnection(cfg);

  pc.onicegatheringstatechange = ()=>log('gathering:', pc.iceGatheringState);
  pc.oniceconnectionstatechange = ()=>{
    log('ice:', pc.iceConnectionState);
    const s=pc.connectionState;
    badge($('#conn'), s||pc.iceConnectionState, (s==='connected')?'ok':((s==='failed'||s==='disconnected')?'bad':'warn'));
  };
  pc.onsignalingstatechange = ()=>log('signal:', pc.signalingState);
  pc.onconnectionstatechange = ()=>{
    const s=pc.connectionState;
    const up=s==='connected';
    ['#btnBeep','#btnChirp','#btnPing'].forEach(id=>$(id).disabled=!up);
  };
  pc.ondatachannel = e=>{ dc=e.channel; attachDC(); };
}

function attachDC(){
  if(!dc) return;
  badge($('#dc'), dc.readyState, dc.readyState==='open'?'ok':'warn');
  dc.onopen  = ()=>badge($('#dc'),'open','ok');
  dc.onclose = ()=>badge($('#dc'),'closed','bad');
  dc.onmessage = e=>log('RX', e.data);
}
function send(m){ if(dc&&dc.readyState==='open') dc.send(m); }
$('#btnBeep').onclick = ()=>send('BEEP');
$('#btnChirp').onclick= ()=>send('CHIRP');
$('#btnPing').onclick = ()=>send('PING');

/* =================== QR make/scan (dense + forced v4 split) =================== */
const QR_PREFIX = 'UCP2|'; // multipart: UCP2|<total>|<index>|<payload>
let densePayload = '';        // packed string (b64url deflated JSON)
let chunks = [];              // forced v4 chunks
let chunkIdx = 0;
let qrMode = 'dense';         // 'dense' or 'multi'
const MAX_V4_BYTES = 640;     // approx payload cap for v4 (conservative)

function renderQRString(txt, versionAuto, ecc){
  // versionAuto=true => let library pick smallest; otherwise force v4
  const q = qrcode(versionAuto?0:4, ecc);
  q.addData(txt);
  q.make();
  return q.createSvgTag(versionAuto?3:6); // scale: auto smaller, v4 larger modules
}
function showQR(){
  const ecc = $('#robustECC').checked ? 'M' : 'L';
  if(qrMode==='dense'){
    $('#qrWrap').innerHTML = renderQRString(densePayload, true, ecc);
    $('#qrNav').style.display='none';
  }else{
    const p = `${QR_PREFIX}${chunks.length}|${chunkIdx+1}|${chunks[chunkIdx]}`;
    $('#qrWrap').innerHTML = renderQRString(p, false, ecc); // force v4
    $('#qrIndex').textContent = `${chunkIdx+1}/${chunks.length}`;
    $('#qrNav').style.display='flex';
  }
}
$('#qrPrev').onclick = ()=>{ chunkIdx=(chunkIdx-1+chunks.length)%chunks.length; showQR(); };
$('#qrNext').onclick = ()=>{ chunkIdx=(chunkIdx+1)%chunks.length; showQR(); };

function forceSplitToV4(s){
  // Always split into the minimal number of parts (1..4), but force ≥2 for visibility when user clicks.
  const maxParts = 4;
  const needParts = Math.min(maxParts, Math.max(2, Math.ceil(s.length / MAX_V4_BYTES)));
  const sz = Math.ceil(s.length / needParts);
  const out=[];
  for(let i=0;i<needParts;i++) out.push(s.slice(i*sz, (i+1)*sz));
  return out;
}

/* Scanner + assembly */
let scanner = null;
let asm = {total:0, got:new Set(), parts:[]};
function resetAsm(){ asm={total:0,got:new Set(),parts:[]}; $('#qrProgress').textContent=''; }
function stopScanner(){
  if(scanner){
    scanner.stop().then(()=>scanner.clear()).catch(()=>{}); scanner=null;
    $('#scanStart').disabled=false; $('#scanStop').disabled=true;
  }
}
function absorb(text){
  if(text.startsWith(QR_PREFIX)){
    const rest=text.slice(QR_PREFIX.length);
    const p1=rest.indexOf('|'), p2=rest.indexOf('|',p1+1);
    if(p1<0||p2<0){ log('ERR multipart parse'); return; }
    const total=+rest.slice(0,p1), index=+rest.slice(p1+1,p2), data=rest.slice(p2+1);
    if(!asm.total){ asm.total=total; asm.parts=Array(total).fill(''); }
    asm.got.add(index); asm.parts[index-1]=data;
    $('#qrProgress').textContent = `Got parts: ${[...asm.got].sort((a,b)=>a-b).join(', ')} / ${asm.total}`;
    if(asm.got.size===asm.total){
      const packed=asm.parts.join('');
      resetAsm(); applyPacked(packed);
    }
  } else {
    applyPacked(text);
  }
}

async function applyPacked(packed){
  let obj;
  try{ obj=unpack(packed); }
  catch(e){ log('ERR unpack', e.message||e); return; }

  if(!pc){ newPC(); }

  // { r:'h'|'j', s:{u,p,f,c:{ip,pt}} }
  if(!obj || !obj.r || !obj.s || !obj.s.u || !obj.s.p || !obj.s.f || !obj.s.c){ log('ERR payload malformed'); return; }

  if(role==='join' && obj.r==='h'){
    // Joiner receives Host tiny -> set remote offer -> create local answer -> show reply QR
    try{
      const offer = { type:'offer', sdp: sdpOfferFromTiny(obj.s) };
      await pc.setRemoteDescription(offer);
      dc = pc.createDataChannel('x'); // or wait for ondatachannel; either is fine
      attachDC();
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);

      // Build tiny from our local answer and show as QR (dense first)
      const tiny = buildTinyFromLocal(pc.localDescription.sdp);
      densePayload = pack({ r:'j', s: tiny });
      qrMode='dense'; $('#qrTrouble').disabled=false; showQR();
      log('Joiner: reply QR ready — show to Host');

    }catch(e){
      log('ERR joiner apply host tiny', e.message||e);
    }

  } else if(role==='host' && obj.r==='j'){
    // Host receives Joiner tiny -> set remote answer -> done
    try{
      const answer = { type:'answer', sdp: sdpAnswerFromTiny(obj.s) };
      await pc.setRemoteDescription(answer);
      log('Host: applied joiner answer from tiny — connecting…');
      stopScanner();
    }catch(e){
      log('ERR host apply joiner tiny', e.message||e);
    }

  } else {
    log('ERR role mismatch. You are', role, 'but received payload for', obj.r==='h'?'Host':'Joiner');
  }
}

/* ============ UI handlers ============ */
$('#roleHost').onclick = ()=>setRole('host');
$('#roleJoin').onclick = ()=>setRole('join');

$('#qrMake').onclick = async()=>{
  if(!role){ alert('Pick role first'); return; }
  densePayload=''; chunks=[]; chunkIdx=0; qrMode='dense'; $('#qrNav').style.display='none';
  $('#qrTrouble').disabled = true;

  if(pc){ try{ pc.close(); }catch{} pc=null; }
  newPC();

  try{
    if(role==='host'){
      // Host: create an offer with datachannel
      dc = pc.createDataChannel('x'); attachDC();
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      log('Host setLocalDescription(offer). Waiting for first host IPv4 candidate…');

      let gotTiny=false;
      pc.onicecandidate = (e)=>{
        if(gotTiny) return;
        if(e.candidate){
          // Try to build tiny as soon as we see a good host v4
          const sdpNow = pc.localDescription?.sdp||'';
          const cand = parseFirstHostV4(sdpNow);
          if(cand){
            try{
              const tiny = buildTinyFromLocal(sdpNow);
              densePayload = pack({ r:'h', s: tiny });
              qrMode='dense'; showQR(); $('#qrTrouble').disabled=false;
              gotTiny=true;
              log('First host IPv4 candidate found; dense Host QR ready.');
            }catch(err){
              // fall through to gathering-complete
            }
          }
        }
      };

      pc.onicegatheringstatechange = ()=>{
        if(pc.iceGatheringState==='complete' && !densePayload){
          const sdpNow = pc.localDescription?.sdp||'';
          const cand = parseFirstHostV4(sdpNow);
          if(cand){
            try{
              const tiny = buildTinyFromLocal(sdpNow);
              densePayload = pack({ r:'h', s: tiny });
              qrMode='dense'; showQR(); $('#qrTrouble').disabled=false;
              log('Gathering complete — Host dense QR ready (fallback).');
            }catch(err){
              log('ERR after complete (host):', err.message||err);
            }
          } else {
            log('No suitable host IPv4 candidate in SDP after complete.');
          }
        }
      };

    } else {
      // Joiner: we don't know host yet; user will scan host QR then we produce answer QR
      log('Joiner: click Start Camera Scan and scan Host QR.');
    }

  }catch(e){
    log('ERR qrMake', e.message||e);
  }
};

$('#qrTrouble').onclick = ()=>{
  if(!densePayload){ log('Nothing to split yet. Create your QR first.'); return; }
  chunks = forceSplitToV4(densePayload);
  chunkIdx = 0;
  qrMode='multi';
  showQR();
  log(`Forced split into ${chunks.length} v4 chunks.`);
};

$('#scanStart').onclick = ()=>{
  try{
    if(scanner){ return; }
    scanner = new Html5Qrcode("reader");
    $('#scanStart').disabled=true; $('#scanStop').disabled=false;
    scanner.start(
      {facingMode:"environment"},
      {fps:10, qrbox:240},
      txt => {
        absorb(txt);
        // If we got a single dense payload (i.e., not multipart), stop right away
        if(!txt.startsWith(QR_PREFIX)) stopScanner();
      },
      _err => {}
    ).catch(err=>log('scan ERR', err));
  }catch(e){ log('scanner init ERR', e.message||e); }
};
$('#scanStop').onclick = ()=> stopScanner();

$('#qrApply').onclick = ()=>{
  const t=$('#qrPaste').value.trim();
  if(t){ absorb(t); $('#qrPaste').value=''; }
};

/* Actions */
$('#btnBeep').onclick = ()=>send('BEEP');
$('#btnChirp').onclick= ()=>send('CHIRP');
$('#btnPing').onclick = ()=>send('PING');

</script>
</body>
</html>
