<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Rapid Pair — LAN QR (tiny SDP + v4 fallback)</title>
<style>
  :root { --muted:#666; }
  body{margin:0;padding:16px;font:15px/1.45 system-ui,Segoe UI,Roboto,Helvetica,Arial;background:#f7f7f8;color:#222}
  h1{margin:0 0 12px;font-size:18px}
  .row{display:grid;gap:12px;grid-template-columns:1fr}
  @media(min-width:900px){.row{grid-template-columns:1fr 1fr}}
  .card{background:#fff;border:1px solid #ddd;border-radius:12px;padding:12px;margin:10px 0}
  button{padding:8px 12px;border-radius:10px;border:1px solid #ccc;background:#f5f5f5;cursor:pointer}
  button:disabled{opacity:.55;cursor:not-allowed}
  input,textarea{padding:6px;border:1px solid #ccc;border-radius:8px}
  textarea{width:100%;height:110px;font:12px monospace}
  .status{display:inline-block;padding:2px 8px;border-radius:999px;font-size:.9rem}
  .ok{background:#e8f5e9;color:#1b5e20} .warn{background:#fff8e1;color:#795548} .bad{background:#ffebee;color:#b71c1c}
  #log{font-size:.85rem;max-height:240px;overflow:auto;white-space:pre-wrap;border:1px dashed #ddd;padding:8px;border-radius:8px;background:#fafafa}
  .muted{color:var(--muted)}
  #qrWrap svg{max-width:100%}
  .qr-grid{display:flex;gap:8px;flex-wrap:wrap;align-items:flex-start}
  .qr-item{display:flex;flex-direction:column;align-items:center}
  .qr-item svg{border:1px solid #ddd;border-radius:8px}
  #reader{width:320px;max-width:100%;border:1px solid #ddd;border-radius:8px;overflow:hidden}
  .qr-badges{display:flex;gap:6px;align-items:center;margin-top:6px}
  .qr-idx{font-size:12px;color:#444}
  #ver{color:#666;font-size:.8rem}
</style>
<!-- local libs next to this file -->
<script src="qrcode.js"></script>
<script src="pako.min.js"></script>
<script src="html5-qrcode.min.js"></script>
</head>
<body>
<h1>Rapid Pair — LAN QR (tiny SDP + v4 fallback) <span id="ver">v0.8</span></h1>

<div class="row">
  <div class="card">
    <h2>Role</h2>
    <button id="roleHost">Host</button>
    <button id="roleJoin">Joiner</button>
    <span id="roleBadge" class="status warn">no role</span>
  </div>
  <div class="card">
    <h2>Status</h2>
    <div>Peer: <span id="conn" class="status warn">idle</span> &nbsp; DataChannel: <span id="dc" class="status warn">-</span></div>
    <div id="log"></div>
  </div>
</div>

<div class="card">
  <h2>QR (offline, same LAN)</h2>
  <div class="row">
    <div class="card">
      <h3>Make & show my QR</h3>
      <button id="qrMake" disabled>Create my QR</button>
      <div class="qr-badges">
        <button id="qrTrouble" style="display:none;">⚠ Trouble scanning? (v4 split)</button>
        <label><input type="checkbox" id="robustECC"> Robust ECC (M)</label>
      </div>
      <div id="qrWrap" style="margin-top:8px"></div>
    </div>
    <div class="card">
      <h3>Scan partner QR</h3>
      <button id="scanStart" disabled>Start Camera Scan</button>
      <button id="scanStop" disabled>Stop</button>
      <div id="reader"></div>
      <textarea id="qrPaste" placeholder="(Fallback) Paste scanned text…"></textarea>
      <button id="qrApply" disabled>Apply</button>
      <div id="qrProgress" class="muted" style="margin-top:6px"></div>
    </div>
  </div>
  <div class="muted">Tip: On the same LAN, this is instant. We include just one host IPv4 candidate to keep QR small and fast.</div>
</div>

<div class="card">
  <h2>Actions</h2>
  <button id="btnBeep" disabled>Beep</button>
  <button id="btnChirp" disabled>Chirp</button>
  <button id="btnPing" disabled>Ping</button>
</div>

<script>
/* ========= Tiny logger ========= */
const $ = s=>document.querySelector(s), logEl=$('#log');
function log(...a){ const line=a.join(' '); console.log('[LOG]', line); logEl.textContent+=line+"\n"; logEl.scrollTop=logEl.scrollHeight; }
function badge(el,t,c){ el.textContent=t; el.className='status '+c; }

/* ========= Base64URL + pack ========= */
function b64urlFromU8(u8){
  let bin=''; for(let i=0;i<u8.length;i++) bin+=String.fromCharCode(u8[i]);
  const b64=btoa(bin);
  return b64.replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
}
function u8FromB64url(s){
  const b64=s.replace(/-/g,'+').replace(/_/g,'/').padEnd(Math.ceil(s.length/4)*4,'=');
  const bin=atob(b64); const u8=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) u8[i]=bin.charCodeAt(i);
  return u8;
}
function pack(obj){
  const json = new TextEncoder().encode(JSON.stringify(obj));
  const def = pako.deflate(json);
  return 'U2|' + b64urlFromU8(def);
}
function unpack(txt){
  if(txt.startsWith('U2|')) txt = txt.slice(3);
  const u8 = u8FromB64url(txt);
  const inf = pako.inflate(u8);
  return JSON.parse(new TextDecoder().decode(inf));
}

/* ========= Role + UI ========= */
let role=null;
function setRole(r){
  role=r; badge($('#roleBadge'), r==='host'?'Host':'Joiner','ok');
  const isHost = r==='host';
  $('#qrMake').disabled=false;
  $('#scanStart').disabled=false;
  $('#scanStop').disabled=false;
  $('#qrApply').disabled=false;
  log(`Role set to ${r}`);
}
$('#roleHost').onclick=()=>setRole('host');
$('#roleJoin').onclick=()=>setRole('join');

/* ========= WebRTC core ========= */
let pc=null, dc=null, scanner=null;
/** Prefer LAN-only: no STUN/TURN for speed. */
function newPC(){
  const cfg = {iceServers:[]};
  const p = new RTCPeerConnection(cfg);

  p.onicegatheringstatechange = ()=>log('gathering:', p.iceGatheringState);
  p.oniceconnectionstatechange = ()=>{ 
    log('ice:', p.iceConnectionState);
    const s=p.iceConnectionState;
    badge($('#conn'), s, s==='connected'?'ok':(s==='failed'||s==='disconnected'?'bad':'warn'));
  };
  p.onsignalingstatechange = ()=>log('signal:', p.signalingState);
  p.onconnectionstatechange = ()=>{
    const s = p.connectionState;
    badge($('#conn'), s, s==='connected'?'ok':(s==='failed'?'bad':'warn'));
    const ok = s==='connected';
    ['#btnBeep','#btnChirp','#btnPing'].forEach(id=>$(id).disabled=!ok);
    if(ok) stopScanner();
  };
  p.ondatachannel = e=>{ dc=e.channel; attachDC(); };
  return p;
}
function attachDC(){
  if(!dc) return;
  badge($('#dc'), dc.readyState, dc.readyState==='open'?'ok':'warn');
  dc.onopen=()=>badge($('#dc'),'open','ok');
  dc.onclose=()=>badge($('#dc'),'closed','bad');
  dc.onmessage=e=>log('RX', e.data);
}
function send(m){ if(dc&&dc.readyState==='open') dc.send(m); }
$('#btnBeep').onclick = ()=>send('BEEP');
$('#btnChirp').onclick= ()=>send('CHIRP');
$('#btnPing').onclick = ()=>send('PING');

/* ========= SDP minification helpers ========= */
/** pick first host IPv4 candidate from a local SDP */
function pickHostV4Candidate(sdp){
  const lines = sdp.split(/\r?\n/);
  let candLine = null;
  for(const ln of lines){
    if(!ln.startsWith('a=candidate:')) continue;
    // a=candidate:... <comp> <proto> <prio> <ip> <port> typ <type> ...
    const m = ln.match(/^a=candidate:[^\s]+\s+\d+\s+\S+\s+\d+\s+(\d+\.\d+\.\d+\.\d+)\s+(\d+)\s+typ\s+(\S+)/);
    if(!m) continue;
    const ip=m[1], port=m[2], typ=m[3];
    // private IPv4 ranges only
    if(typ==='host' && (
      ip.startsWith('10.') ||
      ip.startsWith('192.168.') ||
      (ip.startsWith('172.') && (parseInt(ip.split('.')[1],10)>=16 && parseInt(ip.split('.')[1],10)<=31))
    )){
      candLine = ln.trim();
      break;
    }
  }
  return candLine;
}
function extractField(re, sdp, label){
  const m = sdp.match(re);
  if(!m){ log(`WARN missing ${label} in local SDP`); return null; }
  return m[1];
}
/** build a tiny application-only SDP (datachannel) with one host v4 candidate */
function buildTinySDP(fromLocal){
  const ufrag = extractField(/^a=ice-ufrag:([^\r\n]+)/m, fromLocal, 'ice-ufrag');
  const pwd   = extractField(/^a=ice-pwd:([^\r\n]+)/m, fromLocal, 'ice-pwd');
  const fp    = extractField(/^a=fingerprint:sha-256\s+([A-F0-9:]+)/m, fromLocal, 'fingerprint');
  const cand  = pickHostV4Candidate(fromLocal);
  if(!ufrag || !pwd || !fp || !cand){
    throw new Error('tinySDP: missing one of ufrag/pwd/fingerprint/hostv4 candidate');
  }
  // Minimal datachannel m-section with a single candidate
  return [
    'v=0',
    'o=- 0 0 IN IP4 127.0.0.1',
    's=-',
    't=0 0',
    'a=group:BUNDLE 0',
    'a=extmap-allow-mixed',
    'm=application 9 UDP/DTLS/SCTP webrtc-datachannel',
    'c=IN IP4 0.0.0.0',
    `a=ice-ufrag:${ufrag}`,
    `a=ice-pwd:${pwd}`,
    `a=fingerprint:sha-256 ${fp}`,
    'a=setup:actpass',
    'a=mid:0',
    'a=sctp-port:5000',
    'a=max-message-size:262144',
    cand
  ].join('\r\n') + '\r\n';
}

/* ========= QR rendering (single dense + v4 fallback) ========= */
const QR_PREFIX='U2|'; // already used in pack()
const V4_MAX_SAFE = 80; // qrcode v4 L shows ~640 bits => ~80 bytes; keep headroom per chunk header
const CHUNK_PAYLOAD = 60; // conservative payload per v4 chunk

function renderQR(svgContainer, text, version=0, ecc='L'){
  const qr = qrcode(version, ecc); // version 0 => auto
  qr.addData(text);
  qr.make();
  const svg = qr.createSvgTag(4); // scale
  svgContainer.innerHTML = svg;
}

/** split packed into N v4 chunks with minimal count */
function splitForV4(packed){
  // Header for chunks: U2C|N|i|...
  // Keep chunk payload <= CHUNK_PAYLOAD
  const chunks = [];
  const N = Math.ceil(packed.length / CHUNK_PAYLOAD);
  for(let i=0;i<N;i++){
    const seg = packed.slice(i*CHUNK_PAYLOAD, (i+1)*CHUNK_PAYLOAD);
    chunks.push(`U2C|${N}|${i+1}|${seg}`);
  }
  return chunks;
}
function tryRenderSingleOrOfferSplit(packed){
  const ecc = $('#robustECC').checked ? 'M' : 'L';
  $('#qrWrap').innerHTML='';
  $('#qrTrouble').style.display='none';

  try{
    renderQR($('#qrWrap'), packed, 0, ecc); // auto size big dense QR
    $('#qrTrouble').style.display='inline';
    log('QR: single dense rendered');
  }catch(e){
    log('QR single overflow, splitting into v4...', e.message||e);
    showV4Grid(packed);
  }
}
function showV4Grid(packed){
  const ecc = $('#robustECC').checked ? 'M' : 'L';
  const chunks = splitForV4(packed);
  const grid = document.createElement('div');
  grid.className='qr-grid';
  $('#qrWrap').innerHTML='';
  const version = 4; // fixed version 4

  chunks.forEach((c, idx)=>{
    const item = document.createElement('div');
    item.className='qr-item';
    const box = document.createElement('div');
    box.style.maxWidth='156px';
    renderQR(box, c, version, ecc);
    const cap = document.createElement('div');
    cap.className='qr-idx';
    cap.textContent = `Part ${idx+1}/${chunks.length}`;
    item.appendChild(box);
    item.appendChild(cap);
    grid.appendChild(item);
  });
  $('#qrWrap').appendChild(grid);
  $('#qrTrouble').style.display='none';
  log(`QR: rendered ${chunks.length} × v4`);
}

/* ========= QR assemble / scanner ========= */
let asm = {total:0, got:new Set(), parts:[]};

function resetAsm(){
  asm = {total:0,got:new Set(),parts:[]};
  $('#qrProgress').textContent='';
}
function absorb(txt){
  // Chunked?
  if(txt.startsWith('U2C|')){
    const rest = txt.slice(4);
    const p1 = rest.indexOf('|'), p2 = rest.indexOf('|', p1+1);
    if(p1<0||p2<0){ log('ERR chunk header parse'); return; }
    const total = +rest.slice(0,p1);
    const index = +rest.slice(p1+1,p2);
    const data  = rest.slice(p2+1);

    if(!asm.total){ asm.total = total; asm.parts = Array(total).fill(''); }
    asm.got.add(index); asm.parts[index-1]=data;
    $('#qrProgress').textContent = `Got parts: ${[...asm.got].sort().join(', ')} / ${asm.total}`;

    if(asm.got.size===asm.total){
      const packed = asm.parts.join('');
      resetAsm();
      applyPacked(packed);
    }
    return;
  }
  // Single packed
  applyPacked(txt);
}

/* ========= Build + show my QR (Host or Joiner) ========= */
async function showHostQR(){
  if(!pc) pc=newPC();
  if(dc) try{ dc.close(); }catch{}
  dc = pc.createDataChannel('x'); attachDC();

  // We'll render as soon as we see the first host v4 candidate
  let firstShown = false;
  pc.onicecandidate = e=>{
    if(firstShown || !e.candidate) return;
    // after setLocalDescription(offer), candidate events include host v4 quickly
    const candStr = 'candidate:' + e.candidate.candidate.split('candidate:')[1];
    if(!/ typ host /.test(candStr)) return; // ignore non-host
    const m = candStr.match(/\s(\d+\.\d+\.\d+\.\d+)\s+(\d+)\s+typ/);
    if(!m) return;
    // Build tiny SDP now using localDescription
    try{
      const tiny = buildTinySDP(pc.localDescription.sdp);
      const packed = pack({r:'h', t:'o', s: tiny});
      log('Host: first host candidate. Rendering QR…');
      tryRenderSingleOrOfferSplit(packed);
      firstShown = true;
    }catch(err){
      log('ERR tinySDP host', err.message||err);
    }
  };

  const offer = await pc.createOffer({iceRestart:false});
  await pc.setLocalDescription(offer);
  log('Host setLocalDescription(offer). Waiting for first host candidate…');

  // Safety: if nothing after 1.5s but gathering complete, try anyway (may still be LAN host cand inside SDP)
  const t0 = Date.now();
  const guard = setInterval(()=>{
    if(firstShown) { clearInterval(guard); return; }
    if(pc.iceGatheringState==='complete' || Date.now()-t0>2500){
      clearInterval(guard);
      try{
        const tiny = buildTinySDP(pc.localDescription.sdp);
        const packed = pack({r:'h', t:'o', s: tiny});
        log('Host: guard fired. Rendering QR from gathered SDP.');
        tryRenderSingleOrOfferSplit(packed);
        firstShown = true;
      }catch(err){
        log('ERR guard tinySDP host', err.message||err);
      }
    }
  }, 150);
}

async function showJoinerQR(){
  // Joiner shouldn't create its QR immediately. The Joiner **scans Host** first,
  // then we create pc (if needed), set remote offer, create answer, and show QR.
  log('Joiner: waiting to scan Host QR (offer) — then I will show my QR automatically.');
}

/* ========= Apply packed (from scanning or pasted) ========= */
async function applyPacked(packed){
  try{
    const obj = unpack(packed);
    if(!pc) pc=newPC();

    if(role==='join' && obj.r==='h' && obj.t==='o'){
      // Joiner got Host offer
      log('Joiner: got Host offer');
      await pc.setRemoteDescription({type:'offer', sdp: obj.s});
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);

      // Build tiny answer SDP with one host v4 candidate (wait briefly for host v4)
      let tinyAns=null;
      const t0 = Date.now();
      await new Promise(resolve=>{
        const onCand = ()=> {
          try{
            tinyAns = buildTinySDP(pc.localDescription.sdp);
            resolve();
          }catch{
            if(pc.iceGatheringState==='complete' || Date.now()-t0>1500) resolve();
          }
        };
        pc.onicecandidate = e=>{
          if(!e.candidate) { onCand(); return; }
          const s = e.candidate.candidate;
          if(/ typ host /.test(s) && /\d+\.\d+\.\d+\.\d+/.test(s)) onCand();
        };
        // also a timer in case no onicecandidate fires
        setTimeout(onCand, 1600);
      });
      if(!tinyAns){
        tinyAns = buildTinySDP(pc.localDescription.sdp); // last resort, throws if truly missing
      }
      const packedAns = pack({r:'j', t:'a', s: tinyAns});
      tryRenderSingleOrOfferSplit(packedAns);
      log('Joiner: answer ready — show this QR to Host.');
      stopScanner(); // we’re done on Joiner side
      return;
    }

    if(role==='host' && obj.r==='j' && obj.t==='a'){
      // Host got Joiner answer
      log('Host: got Joiner answer');
      await pc.setRemoteDescription({type:'answer', sdp: obj.s});
      stopScanner(); // we’re done
      return;
    }

    log('ERR role/type mismatch or unsupported payload', JSON.stringify(obj));
  }catch(e){
    log('ERR', e.message||e);
  }
}

/* ========= Camera scanner ========= */
function stopScanner(){
  if(!scanner) return;
  scanner.stop().then(()=>scanner.clear()).catch(()=>{}); 
  scanner=null;
  $('#scanStart').disabled=false;
  $('#scanStop').disabled=true;
  log('Scanner stopped');
}
$('#scanStart').onclick=()=>{
  try{
    scanner = new Html5Qrcode("reader");
    scanner.start(
      {facingMode:"environment"},
      {fps:10, qrbox:240},
      txt => absorb(txt),
      _err => {}
    ).then(()=>{
      $('#scanStart').disabled=true;
      $('#scanStop').disabled=false;
      log('Scanner started');
    }).catch(err=>log('scan start ERR', err));
  }catch(e){ log('scanner init ERR', e.message||e); }
};
$('#scanStop').onclick=()=>stopScanner();

/* ========= Buttons ========= */
$('#qrMake').onclick=async()=>{
  if(!role){ alert('Pick role first'); return; }
  if(role==='host') await showHostQR();
  else await showJoinerQR();
};
$('#qrTrouble').onclick=()=>{
  // Re-render whatever’s currently in #qrWrap as v4 grid by re-splitting from the last packed
  // We don’t keep the last packed globally, so pick it from the current QR text by asking user to paste if needed.
  // Simpler: store lastPacked when we render.
  if(window.__lastPacked){
    showV4Grid(window.__lastPacked);
  }else{
    log('No cached payload to split — will split the next one you generate.');
  }
};
$('#qrApply').onclick=()=>{ const t=$('#qrPaste').value.trim(); if(t){ absorb(t); $('#qrPaste').value=''; } };

/* Capture last packed whenever we render single or v4 */
const _origTryRender = tryRenderSingleOrOfferSplit;
tryRenderSingleOrOfferSplit = function(packed){ window.__lastPacked = packed; _origTryRender(packed); };
const _origShowV4 = showV4Grid;
showV4Grid = function(packed){ window.__lastPacked = packed; _origShowV4(packed); };

/* ========= Page init ========= */
log('Ready. Pick Host/Joiner. For instant LAN, this uses one host IPv4 candidate and a tiny SDP.');
badge($('#conn'),'idle','warn');
badge($('#dc'),'-','warn');
</script>
</body>
</html>
