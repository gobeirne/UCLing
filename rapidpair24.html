<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Device Pairing - Controller & Responder</title>
<style>
  body{margin:0;padding:16px;font:15px/1.4 system-ui;background:#f7f7f8;color:#222}
  h1{margin:0 0 12px;font-size:18px}
  .card{background:#fff;border:1px solid #ddd;border-radius:12px;padding:20px;margin:10px auto;max-width:600px}
  button{padding:10px 20px;border-radius:10px;border:1px solid #ccc;background:#f5f5f5;cursor:pointer;font-size:15px;margin:4px}
  button:disabled{opacity:.55;cursor:not-allowed}
  button.primary{background:#e3f2fd;border-color:#1976d2;color:#1976d2;font-weight:600}
  button.success{background:#e8f5e9;border-color:#4caf50}
  input,textarea{padding:10px;border:1px solid #ccc;border-radius:8px;font-size:16px;width:100%;box-sizing:border-box}
  textarea{height:80px;font:12px monospace}
  .status{display:inline-block;padding:3px 10px;border-radius:999px;font-size:.9rem}
  .ok{background:#e8f5e9;color:#1b5e20}
  .warn{background:#fff8e1;color:#795548}
  .bad{background:#ffebee;color:#b71c1c}
  .step{display:none;margin-top:16px}
  .step.active{display:block}
  .mono{font-family:monospace;letter-spacing:2px;font-size:28px;font-weight:700;text-align:center;padding:20px;background:#f0f0f0;border-radius:8px;margin:16px 0}
  .hint{font-size:.9rem;color:#666;margin:8px 0}
  .instruction{font-size:1.1rem;font-weight:600;margin:12px 0;color:#333}
  #qrWrap{text-align:center;margin:16px 0;cursor:pointer;position:relative}
  #qrWrap svg{max-width:100%;height:auto}
  .qr-nav{display:flex;gap:8px;align-items:center;justify-content:center;margin-top:8px;flex-wrap:wrap}
  label{display:inline-flex;align-items:center;gap:4px}
  #reader{width:100%;max-width:400px;margin:12px auto}
  .reconnect-banner{background:#fff8e1;border:2px solid #f57c00;border-radius:8px;padding:12px;text-align:center;font-weight:600;margin:12px 0}
  .work-area{display:none;text-align:center;padding:20px}
  .work-area.active{display:block}
  .work-area button{margin:8px;padding:12px 24px;font-size:16px}
  #logSection{margin-top:40px;padding:20px;background:#fafafa;border-top:2px solid #ddd}
  #logSection h3{margin:0 0 8px;font-size:14px;color:#666;cursor:pointer;user-select:none}
  #log{font-size:.8rem;max-height:200px;overflow:auto;white-space:pre-wrap;background:#fff;border:1px solid #ddd;padding:8px;border-radius:4px;display:none}
  #log.visible{display:block}
  
  .qr-overlay{display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.9);z-index:1000;align-items:center;justify-content:center;flex-direction:column}
  .qr-overlay.active{display:flex}
  .qr-overlay-content{max-width:90vw;max-height:90vh;text-align:center}
  .qr-overlay svg{max-width:90vmin;max-height:90vmin}
  .qr-overlay-close{position:absolute;top:20px;right:20px;background:#fff;border:none;border-radius:50%;width:40px;height:40px;font-size:24px;cursor:pointer}
</style>

<script src="qrcode.js"></script>
<script src="pako.min.js"></script>
<script src="html5-qrcode.min.js"></script>
</head>
<body>
<h1>Device Pairing <span style="color:#666;font-size:.8rem">v4.3</span></h1>

<div class="card" id="pairingCard">
  <div id="step1" class="step active">
    <h2>Select device role</h2>
    <div style="text-align:center">
      <button id="btnController" class="primary">Controller</button>
      <button id="btnResponder" class="primary">Responder</button>
    </div>
  </div>

  <div id="step2controller" class="step">
    <h2>Controller: Choose connection method</h2>
    <div style="text-align:center">
      <button id="btnSameNetwork" class="primary">Same Network (Code)</button>
      <button id="btnDifferentNetwork" class="primary">Different Network (Code)</button>
      <button id="btnNoInternet" class="primary">No Internet (QR)</button>
    </div>
    <p class="hint"><strong>Same Network:</strong> Instant connection via local network.<br>
    <strong>Different Network:</strong> Works across internet (slower setup).<br>
    <strong>No Internet:</strong> Offline QR scanning.</p>
  </div>

  <div id="step3controllerCode" class="step">
    <p class="instruction">Enter this code on the Responder device:</p>
    <div id="controllerCode" class="mono">----</div>
    <div style="text-align:center">
      <button id="btnCopyCode">Copy Code</button>
    </div>
    <p class="hint">Waiting for Responder to connect...</p>
  </div>

  <div id="step3controllerQR" class="step">
    <p class="instruction">Scan this with the Responder's camera:</p>
    <div id="qrWrap"></div>
    <div id="qrNav" class="qr-nav" style="display:none">
      <button id="qrPrev">◀ Prev</button>
      <span id="qrIndex"></span>
      <button id="qrNext">Next ▶</button>
      <label><input type="checkbox" id="autoAdvance" checked><span>Auto (3s)</span></label>
    </div>
    <div style="text-align:center;margin-top:12px">
      <button id="qrTrouble" style="display:none">Trouble scanning? (more chunks)</button>
    </div>
    <p class="hint">Then scan their reply QR when ready.</p>
    <div style="margin-top:16px">
      <button id="scanStartController">Start Camera to Scan Reply</button>
      <button id="scanStopController" disabled>Stop Camera</button>
      <div id="readerController" style="width:100%;max-width:400px;margin:12px auto"></div>
    </div>
  </div>

  <div id="step2responder" class="step">
    <h2>Responder: How is the Controller connecting?</h2>
    <div style="text-align:center">
      <button id="btnTheyHaveCode" class="primary">They have a code</button>
      <button id="btnTheyHaveQR" class="primary">They have a QR code</button>
    </div>
  </div>

  <div id="step3responderCode" class="step">
    <p class="instruction">Enter the code from Controller:</p>
    <input id="responderCodeInput" class="mono" placeholder="####" inputmode="numeric" style="text-align:center;font-size:24px;letter-spacing:4px;max-width:300px;margin:12px auto;display:block"/>
    <div style="text-align:center;margin-top:12px">
      <button id="btnResponderConnect" class="primary">Connect</button>
    </div>
    <p class="hint" id="responderHint">Enter the code above.</p>
  </div>

  <div id="step3responderQR" class="step">
    <p class="instruction">Scan the Controller's QR code:</p>
    <div style="text-align:center;margin:12px 0">
      <button id="scanStartResponder">Start Camera</button>
      <button id="scanStopResponder" disabled>Stop Camera</button>
    </div>
    <div id="qrProgressResponder" style="font-weight:600;color:#666;margin:8px 0;min-height:20px"></div>
    <div id="readerResponder"></div>
    <p class="hint" style="margin-top:12px">Or paste the QR text:</p>
    <textarea id="qrPasteResponder" placeholder="Paste here..."></textarea>
    <div style="text-align:center;margin-top:8px">
      <button id="qrApplyResponder">Apply Pasted Text</button>
    </div>
  </div>

  <div id="step4responderReply" class="step">
    <p class="instruction">Show this QR to the Controller:</p>
    <div id="qrWrapResponderReply"></div>
    <div id="qrNavResponder" class="qr-nav" style="display:none">
      <button id="qrPrevResponder">◀ Prev</button>
      <span id="qrIndexResponder"></span>
      <button id="qrNextResponder">Next ▶</button>
      <label><input type="checkbox" id="autoAdvanceResponder" checked><span>Auto (3s)</span></label>
    </div>
    <div style="text-align:center;margin-top:12px">
      <button id="qrTroubleResponder" style="display:none">Trouble scanning? (more chunks)</button>
    </div>
    <p class="hint">Waiting for Controller to scan...</p>
  </div>
</div>

<div id="reconnectBanner" class="reconnect-banner" style="display:none">
  Connection lost. <button id="btnReconnect" style="margin-left:8px">Reconnect</button>
</div>

<div class="work-area" id="workArea">
  <h2>Connected! <span id="connStatus" class="status ok">Peer: connected</span></h2>
  <p style="color:#666;margin:12px 0">DataChannel: <span id="dcStatus" class="status ok">open</span></p>
  <div style="margin-top:24px">
    <button id="btnBeep" class="primary">Send BEEP</button>
    <button id="btnChirp" class="primary">Send CHIRP</button>
    <button id="btnPing" class="primary">Send PING</button>
  </div>
  <div style="margin-top:24px;padding:12px;background:#f0f0f0;border-radius:8px;min-height:60px" id="messageArea">
    <strong>Messages:</strong>
    <div id="messages"></div>
  </div>
</div>

<div class="qr-overlay" id="qrOverlay">
  <button class="qr-overlay-close" id="qrOverlayClose">×</button>
  <div class="qr-overlay-content" id="qrOverlayContent"></div>
</div>

<div id="logSection">
  <h3 id="logToggle">▼ Console Logs (click to toggle)</h3>
  <div id="log" class="visible"></div>
</div>

<script type="module">
/* ================= Helpers & Logging ================= */
const $=s=>document.querySelector(s), logEl=$('#log');
function log(...a){logEl.textContent+=a.join(' ')+"\n";logEl.scrollTop=logEl.scrollHeight;}
function badge(el,t,c){el.textContent=t;el.className='status '+c;}

$('#logToggle').onclick=()=>{
  $('#log').classList.toggle('visible');
  $('#logToggle').textContent = $('#log').classList.contains('visible') ? '▼ Console Logs (click to toggle)' : '▶ Console Logs (click to toggle)';
};

log('Ready. Select your device role.');

/* Base64url + pako compression */
function b64urlFromU8(u8){
  let bin=''; for(let i=0;i<u8.length;i++) bin+=String.fromCharCode(u8[i]);
  return btoa(bin).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
}
function b64urlToU8(s){
  let b64=s.replace(/-/g,'+').replace(/_/g,'/'); while(b64.length%4) b64+='=';
  const bin=atob(b64); const u8=new Uint8Array(bin.length);
  for(let i=0;i<bin.length;i++) u8[i]=bin.charCodeAt(i);
  return u8;
}
function pack(obj){ 
  const json=JSON.stringify(obj); 
  const def=pako.deflate(json, {level: 9});
  return b64urlFromU8(def); 
}
function unpack(s){ const u8=b64urlToU8(s); const inf=pako.inflate(u8,{to:'string'}); return JSON.parse(inf); }

/* Extract minimal SDP - now handles all candidate types */
function extractMinimalSDP(sdp, type, includeAllCandidates=false){
  const lines = sdp.split('\r\n');
  const minimal = {t: type === 'offer' ? 'o' : 'a', u: '', p: '', f: '', s: '', m: '', c: []};
  let sctpPort = '';
  for(const line of lines){
    if(line.startsWith('a=ice-ufrag:')) minimal.u = line.split(':')[1];
    else if(line.startsWith('a=ice-pwd:')) minimal.p = line.split(':')[1];
    else if(line.startsWith('a=fingerprint:')) {
      const parts = line.split(' ');
      if(parts.length >= 2) minimal.f = parts.slice(1).join(' ');
    }
    else if(line.startsWith('a=setup:')) minimal.s = line.split(':')[1];
    else if(line.startsWith('a=mid:')) minimal.m = line.split(':')[1];
    else if(line.startsWith('a=sctp-port:')) sctpPort = line.split(':')[1];
    else if(line.startsWith('a=candidate:')){
      // Extract candidate type from the line
      const typMatch = line.match(/typ\s+(\w+)/);
      const candType = typMatch ? typMatch[1] : 'host';
      
      if(includeAllCandidates || candType === 'host'){
        const parts = line.substring(12).split(' ');
        if(parts.length >= 6) {
          // Store: foundation|component|protocol|ip|port|type
          minimal.c.push(`${parts[0]}|${parts[1]}|${parts[2]}|${parts[4]}|${parts[5]}|${candType}`);
        }
      }
    }
  }
  if(sctpPort) minimal.sp = sctpPort;
  return minimal;
}

/* Reconstruct SDP - now handles different candidate types */
function reconstructSDP(minimal){
  const isOffer = minimal.t === 'o';
  let sdp = `v=0\r\no=- ${Date.now()} 2 IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\na=group:BUNDLE ${minimal.m}\r\n`;
  if(isOffer) sdp += `a=msid-semantic: WMS\r\n`;
  sdp += `m=application 9 UDP/DTLS/SCTP webrtc-datachannel\r\nc=IN IP4 0.0.0.0\r\n`;
  if(!isOffer) sdp += `a=bundle-only\r\n`;
  sdp += `a=ice-ufrag:${minimal.u}\r\na=ice-pwd:${minimal.p}\r\na=ice-options:trickle\r\n`;
  sdp += `a=fingerprint:sha-256 ${minimal.f.toUpperCase()}\r\na=setup:${minimal.s}\r\na=mid:${minimal.m}\r\n`;
  const sctpPort = minimal.sp || '5000';
  sdp += `a=sctp-port:${sctpPort}\r\na=max-message-size:262144\r\n`;
  
  if(minimal.c && minimal.c.length > 0){
    for(const compactCand of minimal.c){
      const parts = compactCand.split('|');
      if(parts.length >= 6){
        const [foundation, component, protocol, ip, port, type] = parts;
        sdp += `a=candidate:${foundation} ${component} ${protocol} 2130706431 ${ip} ${port} typ ${type} generation 0 network-id 1\r\n`;
      }
    }
  }
  return sdp;
}

/* ================= UI State Management ================= */
let role=null, connectionMethod=null;

function showStep(stepId){
  document.querySelectorAll('.step').forEach(s=>s.classList.remove('active'));
  $(stepId).classList.add('active');
}

$('#btnController').onclick=()=>{
  role='controller';
  log('Role: Controller');
  showStep('#step2controller');
};

$('#btnResponder').onclick=()=>{
  role='responder';
  log('Role: Responder');
  showStep('#step2responder');
};

$('#btnSameNetwork').onclick=()=>{
  connectionMethod='sameNetwork';
  log('Method: Same Network (LAN only, instant)');
  controllerGenerateCodeLAN();
  showStep('#step3controllerCode');
};

$('#btnDifferentNetwork').onclick=()=>{
  connectionMethod='differentNetwork';
  log('Method: Different Network (STUN enabled)');
  controllerGenerateCodeSTUN();
  showStep('#step3controllerCode');
};

$('#btnNoInternet').onclick=()=>{
  connectionMethod='noInternet';
  log('Method: No Internet (QR only)');
  controllerGenerateQR();
  showStep('#step3controllerQR');
};

$('#btnTheyHaveCode').onclick=()=>{
  log('Responder: Waiting for code');
  showStep('#step3responderCode');
};

$('#btnTheyHaveQR').onclick=()=>{
  connectionMethod='noInternet';
  log('Responder: Ready to scan QR');
  showStep('#step3responderQR');
};

$('#btnReconnect').onclick=()=>{
  $('#reconnectBanner').style.display='none';
  $('#pairingCard').style.display='block';
  $('#workArea').classList.remove('active');
  showStep('#step1');
  log('Reconnecting...');
};

/* ================= WebRTC Core ================= */
let pc=null, dc=null, sessionData={};

function newPC(useSTUN=false){
  const cfg = useSTUN ? {
    iceServers: [{urls: 'stun:stun.l.google.com:19302'}]
  } : {iceServers: []};
  
  const p=new RTCPeerConnection(cfg);
  p.onicegatheringstatechange = ()=>log('ICE gathering:', p.iceGatheringState);
  p.oniceconnectionstatechange = ()=>{
    log('ICE connection:', p.iceConnectionState);
    if(p.iceConnectionState === 'failed' || p.iceConnectionState === 'disconnected'){
      handleDisconnect();
    }
  };
  p.onsignalingstatechange = ()=>log('Signaling:', p.signalingState);
  p.onconnectionstatechange = ()=>{
    const s=p.connectionState; 
    log('Connection state:', s);
    badge($('#connStatus'),`Peer: ${s}`, s==='connected'?'ok':(s==='failed'||s==='disconnected'?'bad':'warn'));
    if(s==='connected' && dc && dc.readyState==='open'){
      onConnected();
    } else if(s==='failed' || s==='disconnected'){
      handleDisconnect();
    }
  };
  p.ondatachannel = e=>{ dc=e.channel; attachDC(); };
  return p;
}

function attachDC(){
  if(!dc) return;
  badge($('#dcStatus'),dc.readyState, dc.readyState==='open'?'ok':'warn');
  dc.onopen = ()=>{
    badge($('#dcStatus'),'open','ok');
    log('DataChannel open');
    if(pc && pc.connectionState==='connected') onConnected();
  };
  dc.onclose = ()=>{
    badge($('#dcStatus'),'closed','bad');
    log('DataChannel closed');
    handleDisconnect();
  };
  dc.onmessage = e=>{
    log('RX:', e.data);
    const msgDiv = document.createElement('div');
    msgDiv.textContent = `← ${e.data}`;
    msgDiv.style.color = '#1976d2';
    msgDiv.style.margin = '4px 0';
    $('#messages').appendChild(msgDiv);
  };
}

function send(m){ 
  if(dc&&dc.readyState==='open'){
    dc.send(m);
    log('TX:', m);
    const msgDiv = document.createElement('div');
    msgDiv.textContent = `→ ${m}`;
    msgDiv.style.color = '#2e7d32';
    msgDiv.style.margin = '4px 0';
    $('#messages').appendChild(msgDiv);
  }
}

function onConnected(){
  log('Connected! Hiding pairing card.');
  $('#pairingCard').style.display='none';
  $('#reconnectBanner').style.display='none';
  $('#workArea').classList.add('active');
  stopAllScanners();
}

function handleDisconnect(){
  if($('#workArea').classList.contains('active')){
    log('Connection lost - showing reconnect option');
    $('#reconnectBanner').style.display='block';
  }
}

$('#btnBeep').onclick = ()=>send('BEEP');
$('#btnChirp').onclick= ()=>send('CHIRP');
$('#btnPing').onclick = ()=>send('PING');

/* ================= Firebase ================= */
let fb = {app:null, db:null, auth:null, initialized:false};

async function ensureFirebaseReady(){
  if(fb.initialized) return;
  try{
    const { initializeApp } = await import('https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js');
    const { getAuth, signInAnonymously } = await import('https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js');
    const { getFirestore, doc, getDoc, setDoc, serverTimestamp, onSnapshot } =
      await import('https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js');

    fb.app = initializeApp({
      apiKey: "AIzaSyBZhqD0RE0miHDHhhlDZerGIsD0S5oy4Yw",
      authDomain: "ucpairing.firebaseapp.com",
      projectId: "ucpairing"
    });
    fb.auth = getAuth(fb.app);
    await signInAnonymously(fb.auth);
    fb.db = getFirestore(fb.app);
    fb.doc = doc; fb.getDoc = getDoc; fb.setDoc = setDoc; fb.ts = serverTimestamp; fb.onSnapshot = onSnapshot;
    fb.initialized = true;
    log('Firebase ready');
  }catch(e){ log('Firebase ERR:', e.code, e.message); }
}

/* Controller: Same Network (LAN only, instant) */
let hostRef = null;

async function controllerGenerateCodeLAN(){
  await ensureFirebaseReady();
  
  try{ pc?.close(); }catch{}
  pc = newPC(false); // NO STUN
  dc = pc.createDataChannel('x'); 
  attachDC();
  
  await pc.setLocalDescription(await pc.createOffer());
  log('Controller: creating LAN-only offer...');
  
  if(pc.iceGatheringState !== 'complete'){
    await new Promise(res => {
      const h = () => {
        if(pc.iceGatheringState === 'complete'){
          pc.removeEventListener('icegatheringstatechange', h);
          res();
        }
      };
      pc.addEventListener('icegatheringstatechange', h);
    });
  }
  
  const minimalSDP = extractMinimalSDP(pc.localDescription.sdp, 'offer', false); // host only
  const hostPacked = pack({ role:'host', sdp: minimalSDP });
  log('Offer ready, allocating code...');
  
  async function tryCode(len){
    const code = String(Math.floor(Math.random() * Math.pow(10, len))).padStart(len, '0');
    const ref = fb.doc(fb.db, 'pairs', code);
    const snap = await fb.getDoc(ref);
    if(snap.exists()) return null;
    await fb.setDoc(ref, {offer: hostPacked, ts: fb.ts()});
    return { code, ref };
  }
  
  let result = null;
  for(let i=0; i<50 && !result; i++) result = await tryCode(4);
  if(!result) for(let i=0; i<100 && !result; i++) result = await tryCode(6);
  
  if(!result){ log('ERR: Could not allocate code'); return; }
  
  hostRef = result.ref;
  $('#controllerCode').textContent = result.code;
  log('Code ready:', result.code, '(LAN instant)');
  
  fb.onSnapshot(hostRef, async snap => {
    const data = snap.data() || {};
    if(data.answer && !pc.currentRemoteDescription){
      try{
        const obj = unpack(data.answer);
        const fullSDP = reconstructSDP(obj.sdp);
        await pc.setRemoteDescription({type: obj.sdp.t === 'o' ? 'offer' : 'answer', sdp: fullSDP});
        log('Controller: got answer, connecting...');
      }catch(e){ log('Controller: apply answer ERR:', e.message); }
    }
  });
}

/* Controller: Different Network (STUN enabled) */
async function controllerGenerateCodeSTUN(){
  await ensureFirebaseReady();
  
  try{ pc?.close(); }catch{}
  pc = newPC(true); // STUN enabled
  dc = pc.createDataChannel('x'); 
  attachDC();
  
  await pc.setLocalDescription(await pc.createOffer());
  log('Controller: creating offer with STUN (may take 1-2 sec)...');
  
  if(pc.iceGatheringState !== 'complete'){
    await new Promise(res => {
      const h = () => {
        if(pc.iceGatheringState === 'complete'){
          pc.removeEventListener('icegatheringstatechange', h);
          res();
        }
      };
      pc.addEventListener('icegatheringstatechange', h);
    });
  }
  
  const minimalSDP = extractMinimalSDP(pc.localDescription.sdp, 'offer', true); // ALL candidates
  const hostPacked = pack({ role:'host', sdp: minimalSDP });
  log('Offer ready (with STUN), allocating code...');
  
  async function tryCode(len){
    const code = String(Math.floor(Math.random() * Math.pow(10, len))).padStart(len, '0');
    const ref = fb.doc(fb.db, 'pairs', code);
    const snap = await fb.getDoc(ref);
    if(snap.exists()) return null;
    await fb.setDoc(ref, {offer: hostPacked, ts: fb.ts()});
    return { code, ref };
  }
  
  let result = null;
  for(let i=0; i<50 && !result; i++) result = await tryCode(4);
  if(!result) for(let i=0; i<100 && !result; i++) result = await tryCode(6);
  
  if(!result){ log('ERR: Could not allocate code'); return; }
  
  hostRef = result.ref;
  $('#controllerCode').textContent = result.code;
  log('Code ready:', result.code, '(cross-network)');
  
  fb.onSnapshot(hostRef, async snap => {
    const data = snap.data() || {};
    if(data.answer && !pc.currentRemoteDescription){
      try{
        const obj = unpack(data.answer);
        const fullSDP = reconstructSDP(obj.sdp);
        await pc.setRemoteDescription({type: obj.sdp.t === 'o' ? 'offer' : 'answer', sdp: fullSDP});
        log('Controller: got answer, connecting...');
      }catch(e){ log('Controller: apply answer ERR:', e.message); }
    }
  });
}

$('#btnCopyCode').onclick = async ()=>{
  try{
    await navigator.clipboard.writeText($('#controllerCode').textContent);
    $('#btnCopyCode').textContent = 'Copied!';
    $('#btnCopyCode').classList.add('success');
    setTimeout(()=>{ $('#btnCopyCode').textContent = 'Copy Code'; $('#btnCopyCode').classList.remove('success'); }, 2000);
    log('Code copied');
  }catch{ log('Copy failed'); }
};

/* Responder: Enter code (auto-detects if it has STUN or not) */
$('#btnResponderConnect').onclick = async ()=>{
  await ensureFirebaseReady();
  
  const code = $('#responderCodeInput').value.trim();
  if(!code){ log('Enter a code'); return; }
  
  $('#responderHint').textContent = 'Fetching...';
  
  const ref = fb.doc(fb.db, 'pairs', code);
  const snap = await fb.getDoc(ref);
  
  if(!snap.exists()){ 
    $('#responderHint').textContent = 'Code not found. Check and try again.';
    log('Code not found'); return; 
  }
  
  const data = snap.data() || {};
  if(!data.offer){ 
    $('#responderHint').textContent = 'Code exists but no offer yet. Wait a moment.';
    log('No offer in code'); 
    return; 
  }
  
  $('#responderHint').textContent = 'Connecting...';
  
  const obj = unpack(data.offer);
  
  // Check if offer has non-host candidates (srflx, relay, etc.)
  const hasNonHost = obj.sdp.c && obj.sdp.c.some(c => {
    const parts = c.split('|');
    return parts.length >= 6 && parts[5] !== 'host';
  });
  const useSTUN = hasNonHost;
  
  log('Responder: Offer has STUN candidates:', hasNonHost);
  
  try{ pc?.close(); }catch{}
  pc = newPC(useSTUN);
  
  const fullSDP = reconstructSDP(obj.sdp);
  await pc.setRemoteDescription({type: obj.sdp.t === 'o' ? 'offer' : 'answer', sdp: fullSDP});
  await pc.setLocalDescription(await pc.createAnswer());
  
  if(pc.iceGatheringState !== 'complete'){
    await new Promise(res => {
      const h = () => {
        if(pc.iceGatheringState === 'complete'){
          pc.removeEventListener('icegatheringstatechange', h);
          res();
        }
      };
      pc.addEventListener('icegatheringstatechange', h);
    });
  }
  
  const minimalSDP = extractMinimalSDP(pc.localDescription.sdp, pc.localDescription.type, useSTUN);
  const joinPacked = pack({ role:'join', sdp: minimalSDP });
  
  await fb.setDoc(ref, { answer: joinPacked, ts: fb.ts() }, { merge:true });
  log('Responder: answer uploaded, connecting...');
  $('#responderHint').textContent = 'Answer sent. Waiting for connection...';
};

/* ================= QR Code Generation ================= */
const QR_PREFIX='UCP1|';
const NAV_SCALE=6;

function tryRenderQR(text, typeNumber, ecc='M'){
  const q = qrcode(typeNumber, ecc);
  q.addData(text);
  q.make();
  return q.createSvgTag(NAV_SCALE);
}

function maxPayloadForVersion(ver, parts){
  const capacities = {4: 114, 6: 180, 8: 250, 10: 346, 12: 434, 14: 538, 16: 666, 18: 778, 20: 906, 24: 1174, 28: 1502, 32: 1853, 36: 2132, 40: 2409};
  const maxChars = capacities[ver] || 100;
  const overhead = QR_PREFIX.length + String(parts).length + 1 + String(parts).length + 1;
  return Math.max(0, maxChars - overhead);
}

function makeChunks(packed, forceV4=false){
  if(forceV4){
    const ver = 4; 
    for(let parts=2; parts<=20; parts++){
      const maxPay = maxPayloadForVersion(ver, parts);
      const size = Math.ceil(packed.length / parts);
      if(size <= maxPay){
        const out = [];
        for(let i=0; i<parts; i++){
          const slice = packed.slice(i*size, Math.min((i+1)*size, packed.length));
          const framed = `${QR_PREFIX}${parts}|${i+1}|${slice}`;
          try{
            tryRenderQR(framed, ver, 'M');
            out.push({ver, str: framed});
          }catch(e){ break; }
        }
        if(out.length === parts) return out;
      }
    }
    throw Error('Payload too large for V4');
  } else {
    const versions = [4,6,8,10,12,14,16,18,20,24,28,32,36,40];
    for(let parts=2; parts<=4; parts++){
      for(const ver of versions){
        const size = Math.ceil(packed.length / parts);
        const out = []; let ok = true;
        for(let i=0; i<parts; i++){
          const slice = packed.slice(i*size, Math.min((i+1)*size, packed.length));
          const framed = `${QR_PREFIX}${parts}|${i+1}|${slice}`;
          try{
            tryRenderQR(framed, ver, 'M');
            out.push({ver, str: framed});
          }catch(e){ ok=false; break; }
        }
        if(ok) return out;
      }
    }
    throw Error('Payload too large');
  }
}

let qrPacked='', qrChunks=[], qrIdx=0, autoTimer=null;
let qrPackedResponder='', qrChunksResponder=[], qrIdxResponder=0, autoTimerResponder=null;

function showDenseQR(packed, wrapId, navId, troubleId){
  try{
    const svg = tryRenderQR(packed, 0, 'M');
    $(wrapId).innerHTML = svg;
    $(navId).style.display='none';
    if(troubleId) $(troubleId).style.display='inline';
    log(`Dense QR shown (${packed.length} chars)`);
  }catch(e){
    log('Dense overflow, chunking...');
    const chunks = makeChunks(packed, false);
    if(wrapId === '#qrWrap'){
      qrChunks = chunks; qrIdx=0; showChunkQR();
    } else {
      qrChunksResponder = chunks; qrIdxResponder=0; showChunkQRResponder();
    }
  }
}

function showChunkQR(){
  if(!qrChunks.length) return;
  const {ver,str} = qrChunks[qrIdx];
  const svg = tryRenderQR(str, ver, 'M');
  $('#qrWrap').innerHTML = svg;
  $('#qrIndex').textContent = `${qrIdx+1}/${qrChunks.length} (V${ver})`;
  $('#qrNav').style.display='flex';
  $('#qrTrouble').style.display='inline';
  
  if($('#autoAdvance').checked){
    clearTimeout(autoTimer);
    autoTimer = setTimeout(()=>{
      qrIdx = (qrIdx+1) % qrChunks.length;
      showChunkQR();
    }, 3000);
  }
}

function showChunkQRResponder(){
  if(!qrChunksResponder.length) return;
  const {ver,str} = qrChunksResponder[qrIdxResponder];
  const svg = tryRenderQR(str, ver, 'M');
  $('#qrWrapResponderReply').innerHTML = svg;
  $('#qrIndexResponder').textContent = `${qrIdxResponder+1}/${qrChunksResponder.length} (V${ver})`;
  $('#qrNavResponder').style.display='flex';
  $('#qrTroubleResponder').style.display='inline';
  
  if($('#autoAdvanceResponder').checked){
    clearTimeout(autoTimerResponder);
    autoTimerResponder = setTimeout(()=>{
      qrIdxResponder = (qrIdxResponder+1) % qrChunksResponder.length;
      showChunkQRResponder();
    }, 3000);
  }
}

$('#qrPrev').onclick=()=>{ clearTimeout(autoTimer); qrIdx=(qrIdx-1+qrChunks.length)%qrChunks.length; showChunkQR(); };
$('#qrNext').onclick=()=>{ clearTimeout(autoTimer); qrIdx=(qrIdx+1)%qrChunks.length; showChunkQR(); };
$('#qrPrevResponder').onclick=()=>{ clearTimeout(autoTimerResponder); qrIdxResponder=(qrIdxResponder-1+qrChunksResponder.length)%qrChunksResponder.length; showChunkQRResponder(); };
$('#qrNextResponder').onclick=()=>{ clearTimeout(autoTimerResponder); qrIdxResponder=(qrIdxResponder+1)%qrChunksResponder.length; showChunkQRResponder(); };

$('#qrTrouble').onclick = ()=>{
  if(!qrPacked) return;
  clearTimeout(autoTimer);
  qrChunks = makeChunks(qrPacked, true);
  qrIdx=0; showChunkQR();
  log(`Forced V4: ${qrChunks.length} parts`);
};

$('#qrTroubleResponder').onclick = ()=>{
  if(!qrPackedResponder) return;
  clearTimeout(autoTimerResponder);
  qrChunksResponder = makeChunks(qrPackedResponder, true);
  qrIdxResponder=0; showChunkQRResponder();
  log(`Forced V4: ${qrChunksResponder.length} parts`);
};

$('#qrWrap').onclick = ()=>{
  $('#qrOverlayContent').innerHTML = $('#qrWrap').innerHTML;
  $('#qrOverlay').classList.add('active');
};
$('#qrWrapResponderReply').onclick = ()=>{
  $('#qrOverlayContent').innerHTML = $('#qrWrapResponderReply').innerHTML;
  $('#qrOverlay').classList.add('active');
};
$('#qrOverlayClose').onclick = ()=>$('#qrOverlay').classList.remove('active');
$('#qrOverlay').onclick = (e)=>{
  if(e.target === $('#qrOverlay')) $('#qrOverlay').classList.remove('active');
};

async function controllerGenerateQR(){
  try{ pc?.close(); }catch{}
  pc = newPC(false);
  dc = pc.createDataChannel('x'); 
  attachDC();
  
  await pc.setLocalDescription(await pc.createOffer());
  log('Controller: generating QR (no STUN)...');
  
  if(pc.iceGatheringState !== 'complete'){
    await new Promise(res => {
      const h = () => {
        if(pc.iceGatheringState === 'complete'){
          pc.removeEventListener('icegatheringstatechange', h);
          res();
        }
      };
      pc.addEventListener('icegatheringstatechange', h);
    });
  }
  
  const minimalSDP = extractMinimalSDP(pc.localDescription.sdp, 'offer', false);
  qrPacked = pack({ role:'host', sdp: minimalSDP });
  log(`QR payload: ${qrPacked.length} chars`);
  showDenseQR(qrPacked, '#qrWrap', '#qrNav', '#qrTrouble');
}

/* ================= QR Scanning ================= */
let scannerController=null, scannerResponder=null;
let asm={total:0, got:new Set(), parts:[]};

function resetAsm(){ 
  asm={total:0,got:new Set(),parts:[]}; 
  $('#qrProgressResponder').textContent=''; 
}

function updateProgress(){
  if(!asm.total) return;
  let display = 'Scanned: [';
  for(let i=1; i<=asm.total; i++){
    display += `${i}${asm.got.has(i)?'✓':'◻'}`;
    if(i < asm.total) display += ' ';
  }
  display += `]`;
  $('#qrProgressResponder').textContent = display;
}

function absorb(text, isController=false){
  if(text.startsWith(QR_PREFIX)){
    const rest=text.slice(QR_PREFIX.length);
    const p1=rest.indexOf('|'); const p2=rest.indexOf('|',p1+1);
    if(p1<0||p2<0) return;
    const total=+rest.slice(0,p1), index=+rest.slice(p1+1,p2), data=rest.slice(p2+1);
    if(!asm.total){ asm.total=total; asm.parts=Array(total).fill(''); }
    if(!asm.got.has(index)){ asm.got.add(index); asm.parts[index-1]=data; }
    updateProgress();
    if(asm.got.size===asm.total){
      const packed = asm.parts.join('');
      log('All chunks received!');
      resetAsm();
      applyPacked(packed, isController);
    }
  }else{
    applyPacked(text, isController);
  }
}

async function applyPacked(packed, isController){
  try{
    const obj = unpack(packed);
    
    if(isController && obj.role==='join'){
      if(!pc.currentRemoteDescription){
        const fullSDP = reconstructSDP(obj.sdp);
        await pc.setRemoteDescription({type: obj.sdp.t === 'o' ? 'offer' : 'answer', sdp: fullSDP});
        log('Controller: got answer QR, connecting...');
      }
    } else if(!isController && obj.role==='host'){
      if(!pc) pc=newPC(false);
      if(!pc.currentRemoteDescription){
        const fullSDP = reconstructSDP(obj.sdp);
        await pc.setRemoteDescription({type: obj.sdp.t === 'o' ? 'offer' : 'answer', sdp: fullSDP});
        await pc.setLocalDescription(await pc.createAnswer());
        
        if(pc.iceGatheringState !== 'complete'){
          await new Promise(res => {
            const h = () => {
              if(pc.iceGatheringState === 'complete'){
                pc.removeEventListener('icegatheringstatechange', h);
                res();
              }
            };
            pc.addEventListener('icegatheringstatechange', h);
          });
        }
        
        const minimalSDP = extractMinimalSDP(pc.localDescription.sdp, pc.localDescription.type, false);
        qrPackedResponder = pack({ role:'join', sdp: minimalSDP });
        
        stopScanner(scannerResponder, '#scanStartResponder', '#scanStopResponder');
        showStep('#step4responderReply');
        showDenseQR(qrPackedResponder, '#qrWrapResponderReply', '#qrNavResponder', '#qrTroubleResponder');
        log('Responder: reply QR ready');
      }
    }
  }catch(e){ log('ERR applyPacked:', e.message); }
}

function stopScanner(scanner, startBtn, stopBtn){
  if(!scanner) return null;
  scanner.stop().then(()=>scanner.clear()).catch(()=>{});
  $(startBtn).disabled=false;
  $(stopBtn).disabled=true;
  return null;
}

function stopAllScanners(){
  if(scannerController) scannerController = stopScanner(scannerController, '#scanStartController', '#scanStopController');
  if(scannerResponder) scannerResponder = stopScanner(scannerResponder, '#scanStartResponder', '#scanStopResponder');
}

$('#scanStartController').onclick=()=>{
  resetAsm();
  try{
    scannerController = new Html5Qrcode("readerController");
    scannerController.start({facingMode:"environment"},{fps:10,qrbox:240}, txt=>absorb(txt, true), _err=>{})
      .then(()=>{
        $('#scanStartController').disabled=true;
        $('#scanStopController').disabled=false;
        log('Controller scanner started');
      })
      .catch(err=>log('Controller scan ERR:', err));
  }catch(e){ log('Controller scanner init ERR:', e.message); }
};

$('#scanStopController').onclick=()=>{ 
  scannerController = stopScanner(scannerController, '#scanStartController', '#scanStopController');
  resetAsm();
  log('Controller scanner stopped');
};

$('#scanStartResponder').onclick=()=>{
  resetAsm();
  try{
    scannerResponder = new Html5Qrcode("readerResponder");
    scannerResponder.start({facingMode:"environment"},{fps:10,qrbox:240}, txt=>absorb(txt, false), _err=>{})
      .then(()=>{
        $('#scanStartResponder').disabled=true;
        $('#scanStopResponder').disabled=false;
        log('Responder scanner started');
      })
      .catch(err=>log('Responder scan ERR:', err));
  }catch(e){ log('Responder scanner init ERR:', e.message); }
};

$('#scanStopResponder').onclick=()=>{ 
  scannerResponder = stopScanner(scannerResponder, '#scanStartResponder', '#scanStopResponder');
  resetAsm();
  log('Responder scanner stopped');
};

$('#qrApplyResponder').onclick=()=>{ 
  const t=$('#qrPasteResponder').value.trim(); 
  if(t){ 
    absorb(t, false); 
    $('#qrPasteResponder').value=''; 
  } 
};

</script>
</body>
</html>