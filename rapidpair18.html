<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Rapid Pair — QR (LAN) + Typed Code (Firestore) </title>
<style>
  :root{
    --bg:#f7f7f8; --fg:#222; --card:#fff; --muted:#666; --br:#ddd;
    --ok-bg:#e8f5e9; --ok-fg:#1b5e20; --warn-bg:#fff8e1; --warn-fg:#795548; --bad-bg:#ffebee; --bad-fg:#b71c1c;
  }
  html,body { height:100%; }
  body{ margin:0; padding:16px; background:var(--bg); color:var(--fg);
        font:15px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
  h1{ margin:0 0 12px; font-size:20px; font-weight:700; }
  h2{ margin:0 0 8px; font-size:16px; }
  h3{ margin:0 0 8px; font-size:15px; }

  .row{ display:grid; gap:12px; grid-template-columns:1fr; }
  @media(min-width:1000px){ .row{ grid-template-columns:1fr 1fr; } }

  .card{
    background:var(--card); border:1px solid var(--br); border-radius:12px;
    padding:12px; margin:10px 0;
  }
  button{
    padding:8px 12px; border-radius:10px; border:1px solid #ccc; background:#f5f5f5; cursor:pointer;
  }
  button:disabled{ opacity:.55; cursor:not-allowed; }
  input,textarea{ padding:6px; border:1px solid #ccc; border-radius:8px; }
  textarea{ width:100%; height:110px; font:12px/1.4 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  .status{ display:inline-block; padding:2px 8px; border-radius:999px; font-size:.9rem; vertical-align:middle; }
  .ok{ background:var(--ok-bg); color:var(--ok-fg); }
  .warn{ background:var(--warn-bg); color:var(--warn-fg); }
  .bad{ background:var(--bad-bg); color:var(--bad-fg); }

  #log{ font-size:.85rem; max-height:280px; overflow:auto; white-space:pre-wrap;
        border:1px dashed var(--br); padding:8px; border-radius:8px; background:#fafafa; }

  #qrWrap svg{ max-width:100%; height:auto; display:block; margin:auto; }
  .muted{ color:var(--muted); font-size:.9rem; }
  .qr-nav{ display:flex; gap:8px; align-items:center; justify-content:center; margin-top:8px; }
  #ver{ color:#666; font-size:.85rem; font-weight:400; }
  .pill{ font-size:.75rem; padding:2px 6px; border:1px solid var(--br); border-radius:999px; color:#333; background:#fff; }

  /* Mode tabs */
  .tabs { display:flex; gap:8px; flex-wrap:wrap; }
  .tab-btn { padding:6px 10px; border-radius:999px; border:1px solid var(--br); background:#fff; }
  .tab-btn.active { background:#e3f2fd; border-color:#90caf9; }

  .row-tight{ display:grid; gap:8px; grid-template-columns:auto 1fr auto; align-items:center; }
  .hint{ font-size:.85rem; color:#555; }
  .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
</style>

<!-- Local libs beside this file -->
<script src="qrcode.js"></script>
<script src="pako.min.js"></script>
<script src="html5-qrcode.min.js"></script>
</head>
<body>

<h1>Rapid Pair — QR (LAN) + Typed Code (Firestore) <span id="ver">vRP-merge</span></h1>

<div class="row">
  <!-- Role -->
  <div class="card">
    <h2>Role</h2>
    <div style="display:flex; gap:8px; align-items:center;">
      <button id="roleHost">Host</button>
      <button id="roleJoin">Joiner</button>
      <span id="roleBadge" class="status warn">no role</span>
    </div>
    <p class="muted" style="margin-top:8px;">
      <b>QR mode</b> is offline (LAN-only). If cameras are a pain, use <b>Typed Code</b>
      — it writes/reads the same compact payload via Firestore (4-digit preferred, 6-digit fallback).
    </p>
  </div>

  <!-- Status / Logs -->
  <div class="card">
    <h2>Status</h2>
    <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
      Peer: <span id="conn" class="status warn">idle</span>
      DataChannel: <span id="dc" class="status warn">-</span>
    </div>
    <div id="log" style="margin-top:8px;"></div>
  </div>
</div>

<!-- Mode picker -->
<div class="card">
  <h2>Pairing Mode</h2>
  <div class="tabs">
    <button id="tabQR" class="tab-btn active">QR (offline)</button>
    <button id="tabCODE" class="tab-btn">Typed Code (Firestore)</button>
  </div>
  <div class="hint">Firebase doesn’t initialize until you switch to “Typed Code”.</div>
</div>

<!-- QR Exchange -->
<div class="card" id="qrPane">
  <h2>QR Exchange</h2>
  <div class="row">
    <!-- Make / Show QR -->
    <div class="card">
      <h3>My QR</h3>
      <div style="display:flex; gap:8px; flex-wrap:wrap;">
        <button id="qrMake" disabled>Create my QR</button>
        <button id="qrTrouble" style="display:none;">⚠ Trouble scanning? (force ≤4× V4)</button>
        <button id="qrPrev" style="display:none;">◀ Prev</button>
        <button id="qrNext" style="display:none;">Next ▶</button>
      </div>
      <div id="qrWrap" style="margin-top:8px"></div>
      <div id="qrMeta" class="muted"></div>
    </div>

    <!-- Scan / Apply -->
    <div class="card">
      <h3>Scan partner QR</h3>
      <div id="qrProgress" class="muted" style="margin-bottom:8px"></div>
      <button id="scanStart" disabled>Start Camera Scan</button>
      <button id="scanStop" disabled>Stop</button>
      <div id="reader" style="width:320px;max-width:100%;"></div>
      <textarea id="qrPaste" placeholder="Paste scanned text…"></textarea>
      <button id="qrApply" disabled>Apply</button>
    </div>
  </div>
</div>

<!-- Typed Code pane -->
<div class="card" id="codePane" style="display:none;">
  <h2>Typed Code (Firestore)</h2>

  <div class="card">
    <h3>Host</h3>
    <div class="row-tight">
      <button id="hostBuild" disabled>Build payload</button>
      <span class="hint">Creates tiny SDP from your first host IPv4 candidate.</span>
      <span></span>
      <button id="hostAllocate" disabled>Allocate 4-digit code</button>
      <span class="hint">Falls back to 6-digit if all taken.</span>
      <span></span>
    </div>
    <div style="margin-top:8px;">
      Code: <span id="hostCode" class="mono"></span>
      <button id="hostCopy" disabled>Copy</button>
    </div>
    <div class="hint" style="margin-top:4px;">Joiner can type this code or scan your QR (both carry the same packed payload).</div>
  </div>

  <div class="card">
    <h3>Joiner</h3>
    <div style="display:flex; gap:8px; align-items:center;">
      <label>Enter code: <input id="joinCode" placeholder="#### or ######" class="mono" inputmode="numeric" style="width:9ch"/></label>
      <button id="joinFetch" disabled>Fetch</button>
    </div>
    <div class="hint" style="margin-top:4px;">This will apply Host’s payload and upload your reply automatically.</div>
  </div>
</div>

<div class="card">
  <h2>Actions</h2>
  <button id="btnBeep" disabled>Beep</button>
  <button id="btnChirp" disabled>Chirp</button>
  <button id="btnPing" disabled>Ping</button>
</div>

<script type="module">
/* ================= Helpers & UI ================= */
const $=s=>document.querySelector(s), logEl=$('#log');
function log(...a){ logEl.textContent += a.join(' ') + "\n"; logEl.scrollTop = logEl.scrollHeight; }
function badge(el,t,c){ el.textContent=t; el.className='status '+c; }

/* Base64url (no spread) + pako pack/unpack */
function b64url(u8){
  let bin=''; for(let i=0;i<u8.length;i++) bin+=String.fromCharCode(u8[i]);
  const b64=btoa(bin); let out='';
  for(let i=0;i<b64.length;i++){ const ch=b64[i];
    if(ch==='+') out+='-'; else if(ch==='/') out+='_'; else if(ch==='='){} else out+=ch;
  } return out;
}
function unb64url(s){
  let b64=''; for(let i=0;i<s.length;i++){ const ch=s[i];
    if(ch==='-') b64+='+'; else if(ch==='_') b64+='/'; else b64+=ch;
  } while(b64.length%4) b64+='=';
  const bin=atob(b64); const u8=new Uint8Array(bin.length);
  for(let i=0;i<bin.length;i++) u8[i]=bin.charCodeAt(i);
  return u8;
}
function pack(o){ return b64url(pako.deflate(JSON.stringify(o))); }
function unpack(s){ return JSON.parse(pako.inflate(unb64url(s), {to:'string'})); }

/* ================= Role & Mode ================= */
let role=null;
function setRole(r){
  role=r; badge($('#roleBadge'), r==='host'?'Host':'Joiner','ok');
  // Enable QR create/scan controls relevant to role
  $('#qrMake').disabled = false;
  $('#scanStart').disabled = false;
  $('#scanStop').disabled = false;
  $('#qrApply').disabled = false;

  // Enable code pane buttons (actual Firebase init only on switching to CODE mode)
  $('#hostBuild').disabled   = (r!=='host') ? true : false;
  $('#hostAllocate').disabled= true; // enabled after build
  $('#hostCopy').disabled    = true;
  $('#joinFetch').disabled   = (r!=='join') ? true : false;

  log('Role set to', r);
}
$('#roleHost').onclick=()=>setRole('host');
$('#roleJoin').onclick=()=>setRole('join');

/* Tab switching — Firebase only when CODE tab selected */
let mode='qr';
$('#tabQR').onclick = ()=>{ mode='qr'; $('#tabQR').classList.add('active'); $('#tabCODE').classList.remove('active'); $('#qrPane').style.display='block'; $('#codePane').style.display='none'; log('Mode: QR (offline). Firebase untouched.'); };
$('#tabCODE').onclick= async ()=>{
  mode='code';
  $('#tabCODE').classList.add('active'); $('#tabQR').classList.remove('active'); $('#qrPane').style.display='none'; $('#codePane').style.display='block';
  await ensureFirebaseReady(); // lazy init/Auth only here
  log('Mode: Typed Code. Firebase initialized.');
};

/* ================= WebRTC core (LAN-friendly defaults) ================= */
let pc=null, dc=null;
function newPC(){
  const cfg = { iceServers: [] }; // LAN only for QR tiny SDP; TURN not needed here
  const p = new RTCPeerConnection(cfg);

  p.onicegatheringstatechange = ()=>log('gathering:', p.iceGatheringState);
  p.oniceconnectionstatechange = ()=>log('ice:', p.iceConnectionState);
  p.onsignalingstatechange = ()=>log('signal:', p.signalingState);
  p.onconnectionstatechange = ()=>{
    const s = p.connectionState;
    badge($('#conn'), s, s==='connected'?'ok':(s==='failed'||s==='disconnected'?'bad':'warn'));
    const up = s==='connected';
    ['#btnBeep','#btnChirp','#btnPing'].forEach(id=>$(id).disabled=!up);
  };
  p.ondatachannel = e=>{ dc=e.channel; attachDC(); };
  return p;
}
function attachDC(){
  badge($('#dc'), dc.readyState, dc.readyState==='open'?'ok':'warn');
  dc.onopen  = ()=>badge($('#dc'),'open','ok');
  dc.onclose = ()=>badge($('#dc'),'closed','bad');
  dc.onmessage = e=>log('RX', e.data);
}
function send(m){ if(dc&&dc.readyState==='open') dc.send(m); }
$('#btnBeep').onclick = ()=>send('BEEP');
$('#btnChirp').onclick= ()=>send('CHIRP');
$('#btnPing').onclick = ()=>send('PING');

/* Extract minimal host-v4 tiny SDP */
function extract(re, s){ const m=s.match(re); return m?m[1]:null; }
function pickHostV4Candidate(sdp){
  const lines = sdp.split(/\r?\n/);
  for(const l of lines){
    if(l.startsWith('a=candidate:') && / typ host /.test(l) && /\d+\.\d+\.\d+\.\d+/.test(l) && / udp /.test(l)) return l;
  }
  for(const l of lines){
    if(l.startsWith('a=candidate:') && / typ host /.test(l) && /\d+\.\d+\.\d+\.\d+/.test(l)) return l;
  }
  return null;
}
function buildTinySDP(localSdp){
  const ufrag = extract(/^a=ice-ufrag:(\S+)/m, localSdp);
  const pwd   = extract(/^a=ice-pwd:(\S+)/m, localSdp);
  const fp    = extract(/^a=fingerprint:sha-256\s+([A-F0-9:]+)/m, localSdp);
  const cand  = pickHostV4Candidate(localSdp);
  if(!ufrag || !pwd || !fp || !cand) throw Error('tinySDP missing pieces');

  return `v=0
o=- 0 0 IN IP4 127.0.0.1
s=-
t=0 0
m=application 9 UDP/DTLS/SCTP webrtc-datachannel
c=IN IP4 0.0.0.0
a=ice-ufrag:${ufrag}
a=ice-pwd:${pwd}
a=fingerprint:sha-256 ${fp}
a=setup:actpass
a=mid:0
a=sctp-port:5000
a=max-message-size:262144
${cand}\r\n`;
}

/* ================= QR Encode/Decode ================= */
const QR_PREFIX='U10C|'; // "<prefix><total>|<index>|<base64url>"
let lastPacked = '';     // dense payload
let chunkList  = [];     // chunked strings (already wrapped with header)
let chunkIdx   = 0;

function tryRenderQR(text, typeNumber, ecc='L'){
  const q = qrcode(typeNumber, ecc);
  q.addData(text);
  q.make(); // throws if overflow
  return q.createSvgTag(6);
}
function renderDense(packed){
  lastPacked = packed;
  const q = qrcode(0, 'L');
  q.addData(packed);
  q.make();
  $('#qrWrap').innerHTML = q.createSvgTag(6);
  $('#qrMeta').textContent = `Dense QR (${packed.length} chars). If hard to scan, click “Trouble scanning?”.`;
  $('#qrTrouble').style.display='inline';
  $('#qrPrev').style.display='none';
  $('#qrNext').style.display='none';
}
function makeV4ChunksForced(packed){
  // Force 2..4 parts (never >4), version=4, ECC=L; ensure each part fits comfortably.
  const V4_CAP = 114; // conservative (alphanumeric M is ~114; with framing we aim below ~100)
  for(let parts=2; parts<=4; parts++){
    const size = Math.ceil(packed.length / parts);
    if(size <= 100){ // headroom for header
      const arr=[];
      for(let i=0;i<parts;i++){
        const slice = packed.slice(i*size, Math.min((i+1)*size, packed.length));
        arr.push(`${QR_PREFIX}${parts}|${i+1}|${slice}`);
      }
      return arr;
    }
  }
  // If still too big, just split into 4 anyway; render will throw and we’ll tell the log.
  const size = Math.ceil(packed.length / 4);
  return [0,1,2,3].map(i=>`${QR_PREFIX}4|${i+1}|${packed.slice(i*size, Math.min((i+1)*size, packed.length))}`);
}
function showChunk(){
  const payload = chunkList[chunkIdx];
  try{
    const svg = tryRenderQR(payload, 4, 'L'); // hard v4
    $('#qrWrap').innerHTML = svg;
    $('#qrMeta').textContent = `Part ${chunkIdx+1}/${chunkList.length} (v4)`;
    $('#qrPrev').style.display = chunkIdx>0 ? 'inline' : 'none';
    $('#qrNext').style.display = chunkIdx < (chunkList.length-1) ? 'inline' : 'none';
  }catch(e){
    log('Chunk render overflow. Payload length:', payload.length, e.message||e);
  }
}
$('#qrPrev').onclick=()=>{ if(chunkIdx>0){ chunkIdx--; showChunk(); } };
$('#qrNext').onclick=()=>{ if(chunkIdx<chunkList.length-1){ chunkIdx++; showChunk(); } };

/* Make my QR (Host OR Joiner) */
$('#qrMake').onclick = async ()=>{
  if(!role){ alert('Pick Host or Joiner'); return; }

  if(role === 'host'){
    try{ pc?.close(); }catch{}
    pc = newPC();
    dc = pc.createDataChannel('x'); attachDC();

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    log('Host setLocalDescription(offer). Waiting for first host IPv4 candidate…');

    let done=false;
    pc.onicecandidate = (e)=>{
      if(done) return;
      if(e.candidate){
        const c = e.candidate.candidate || '';
        if(/ typ host /.test(c) && /\d+\.\d+\.\d+\.\d+/.test(c) && / udp /.test(c)){
          done=true;
          try{
            const tiny = buildTinySDP(pc.localDescription.sdp);
            const packed = pack({ r:'h', s: tiny });
            // Try dense first; if overflow, force v4 chunks
            try{
              renderDense(packed);
              log('Dense QR shown (auto). Length:', packed.length);
            }catch(err){
              log('Dense overflow; forcing ≤4×v4…', err.message||err);
              chunkList = makeV4ChunksForced(packed);
              chunkIdx = 0; showChunk();
            }
            // Enable scanning for Host to receive Joiner reply
            $('#scanStart').disabled=false; $('#scanStop').disabled=false; $('#qrApply').disabled=false;
          }catch(ex){ log('ERR building tiny host SDP', ex.message||ex); }
        }
      }
    };
    // Failsafe if gather completes but we missed the onicecandidate branch
    pc.onicegatheringstatechange = ()=>{
      if(pc.iceGatheringState==='complete' && !lastPacked && !chunkList.length){
        try{
          const tiny = buildTinySDP(pc.localDescription.sdp);
          const packed = pack({ r:'h', s: tiny });
          try{
            renderDense(packed);
            log('Gathering complete — dense QR shown. Length:', packed.length);
          }catch(e){
            log('Dense overflow after complete; forcing ≤4×v4…', e.message||e);
            chunkList = makeV4ChunksForced(packed); chunkIdx=0; showChunk();
          }
          $('#scanStart').disabled=false; $('#scanStop').disabled=false; $('#qrApply').disabled=false;
        }catch(e){ log('ERR after complete (host):', e.message||e); }
      }
    };

  }else{
    log('Joiner: scan Host QR first, then this pane will show your reply QR automatically.');
  }
};

/* "Trouble scanning?" always forces v4 chunks (2..4 parts) */
$('#qrTrouble').onclick = ()=>{
  if (lastPacked){
    chunkList = makeV4ChunksForced(lastPacked);
    chunkIdx = 0; showChunk();
  } else {
    log('No dense payload to split yet.');
  }
};

/* Scanner + assembly (QR) */
let scanner=null;
function stopScanner(){ if(!scanner) return; scanner.stop().then(()=>scanner.clear()).catch(()=>{}); scanner=null; }
let asm={total:0, got:new Set(), parts:[]};
function resetAsm(){ asm={total:0,got:new Set(),parts:[]}; $('#qrProgress').textContent=''; }

function absorb(text){
  if(text.startsWith(QR_PREFIX)){
    const rest=text.slice(QR_PREFIX.length);
    const p1=rest.indexOf('|'), p2=rest.indexOf('|',p1+1);
    if(p1<0||p2<0) return;
    const total=+rest.slice(0,p1), index=+rest.slice(p1+1,p2), data=rest.slice(p2+1);
    if(!asm.total){ asm.total=total; asm.parts=Array(total).fill(''); }
    asm.got.add(index); asm.parts[index-1]=data;
    $('#qrProgress').textContent = `Got parts: ${[...asm.got].sort().join(', ')} / ${asm.total}`;
    if(asm.got.size===asm.total){
      const packed=asm.parts.join(''); resetAsm(); applyPacked(packed);
    }
  } else {
    applyPacked(text);
  }
}
async function applyPacked(packed){
  try{
    const obj = unpack(packed); // { r:'h'|'j', s:<tinySDP> }
    if(!pc) pc=newPC();
    if(role==='host' && obj.r==='j'){
      if(!pc.currentRemoteDescription){
        await pc.setRemoteDescription({type:'answer', sdp: obj.s});
        log('QR: answer applied — connecting…');
      } else log('QR: duplicate answer ignored');
    } else if(role==='join' && obj.r==='h'){
      if(!pc.currentRemoteDescription){
        await pc.setRemoteDescription({type:'offer', sdp: obj.s});
        await pc.setLocalDescription(await pc.createAnswer());
        // Wait until gather complete for reply tinySDP
        if(pc.iceGatheringState!=='complete'){
          await new Promise(r=>pc.addEventListener('icegatheringstatechange',()=>pc.iceGatheringState==='complete'&&r()));
        }
        const tiny = buildTinySDP(pc.localDescription.sdp);
        const packedReply = pack({ r:'j', s: tiny });
        // Show joiner reply QR (dense or forced v4)
        try{
          lastPacked=''; // reset dense marker so we render fresh
          renderDense(packedReply);
          log('Joiner reply dense QR shown. Length:', packedReply.length);
        }catch(err){
          log('Joiner reply dense overflow; forcing ≤4×v4…', err.message||err);
          chunkList = makeV4ChunksForced(packedReply); chunkIdx=0; showChunk();
        }
        log('QR: reply ready — show to Host');
      } else log('QR: duplicate offer ignored');
    } else {
      alert('Role mismatch. One must be Host, the other Joiner.');
    }
  }catch(e){ log('ERR applyPacked', e.message||e); }
}
$('#qrApply').onclick=()=>{ const t=$('#qrPaste').value.trim(); if(t){ absorb(t); $('#qrPaste').value=''; } };

$('#scanStart').onclick=()=>{ try{
  scanner = new Html5Qrcode("reader");
  scanner.start({facingMode:"environment"}, {fps:10, qrbox:240}, txt=>absorb(txt), _err=>{})
    .then(()=>log('Scanner started')).catch(err=>log('scan ERR', err));
}catch(e){ log('scanner init ERR', e.message||e); } };
$('#scanStop').onclick = ()=>{ stopScanner(); log('Scanner stopped'); };

/* ================= Typed Code (Firestore) ================= */
/* Lazy Firebase init only when CODE tab selected */
let fb = { app:null, db:null, auth:null, initialized:false };
async function ensureFirebaseReady(){
  if(fb.initialized) return;
  try{
    const { initializeApp }   = await import('https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js');
    const { getAuth, signInAnonymously } = await import('https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js');
    const { getFirestore, doc, getDoc, setDoc, serverTimestamp, onSnapshot } =
      await import('https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js');

    fb.app = initializeApp({
      apiKey:"AIzaSyBZhqD0RE0miHDHhhlDZerGIsD0S5oy4Yw",
      authDomain:"ucpairing.firebaseapp.com",
      projectId:"ucpairing"
    });
    fb.auth = getAuth(fb.app);
    await signInAnonymously(fb.auth);
    fb.db = getFirestore(fb.app);
    // Stash helpers
    fb.doc=doc; fb.getDoc=getDoc; fb.setDoc=setDoc; fb.ts=serverTimestamp; fb.onSnapshot=onSnapshot;

    fb.initialized = true;
    log('Firebase initialized + anonymous auth OK.');
  }catch(e){
    log('Firebase init/auth ERR', e.code||'', e.message||e);
  }
}

/* Host: Build tiny payload (same as QR) */
let hostPacked = '';
$('#hostBuild').onclick = async ()=>{
  if(role!=='host'){ alert('Pick Host'); return; }
  try{ pc?.close(); }catch{}
  pc=newPC();
  dc=pc.createDataChannel('x'); attachDC();
  await pc.setLocalDescription(await pc.createOffer());
  log('Host setLocalDescription(offer). Waiting for ICE gather to finish…');
  if(pc.iceGatheringState!=='complete'){
    await new Promise(res=>{
      const h=()=>{ if(pc.iceGatheringState==='complete'){ pc.removeEventListener('icegatheringstatechange',h); res(); } };
      pc.addEventListener('icegatheringstatechange',h);
    });
  }
  const tiny = buildTinySDP(pc.localDescription.sdp);
  hostPacked = pack({ r:'h', s: tiny });
  log('Host: offer built & packed. Length:', hostPacked.length);
  $('#hostAllocate').disabled=false;
};

/* Host: allocate 4-digit (fallback 6-digit) + write payload */
async function allocateCodeAndWrite(){
  if(!fb.initialized){ await ensureFirebaseReady(); }
  if(!fb.db){ log('Host code ERR no-db'); return; }
  const tries4 = 50; // attempt up to 50 random 4-digit codes
  const tries6 = 200; // then up to 200 six-digit codes

  async function tryCode(len){
    const code = String(Math.floor(Math.random()*Math.pow(10,len))).padStart(len,'0');
    const ref = fb.doc(fb.db, 'pairCodes', code);
    const snap = await fb.getDoc(ref);
    if(snap.exists()) return null; // taken
    await fb.setDoc(ref, {
      hostPacked, createdAt: fb.ts(), mode:'tiny-v1'
    }, { merge:false });
    return { code, ref };
  }

  // 4-digit sweep
  for(let i=0;i<tries4;i++){
    const r = await tryCode(4);
    if(r) return r;
  }
  // 6-digit sweep
  for(let i=0;i<tries6;i++){
    const r = await tryCode(6);
    if(r) return r;
  }
  return null;
}
let hostRef=null;
$('#hostAllocate').onclick = async ()=>{
  if(!hostPacked){ log('Build payload first'); return; }
  const res = await allocateCodeAndWrite().catch(e=>({err:e}));
  if(!res || res.err){ log('Host code ERR', res?.err?.message||res?.err||'unknown'); return; }
  hostRef = res.ref;
  $('#hostCode').textContent = res.code;
  $('#hostCopy').disabled = false;
  log('Host code allocated:', res.code, '(waiting for Joiner reply…)');

  // Listen for joiner reply
  fb.onSnapshot(hostRef, async snap=>{
    const data = snap.data()||{};
    if(data.joinPacked && !pc.currentRemoteDescription){
      try{
        const obj = unpack(data.joinPacked); // { r:'j', s:'answer tiny' }
        await pc.setRemoteDescription({type:'answer', sdp: obj.s});
        log('Host: got reply via code. Connecting…');
      }catch(e){ log('Host: apply reply ERR', e.message||e); }
    }
  });
};
$('#hostCopy').onclick = async ()=>{
  try{
    await navigator.clipboard.writeText($('#hostCode').textContent.trim());
    log('Code copied');
  }catch{ log('Copy failed'); }
};

/* Joiner: enter code → fetch host payload → build & upload reply */
$('#joinFetch').onclick = async ()=>{
  if(role!=='join'){ alert('Pick Joiner'); return; }
  if(!fb.initialized){ await ensureFirebaseReady(); }
  const code = $('#joinCode').value.trim();
  if(!code){ log('Joiner: enter code'); return; }

  const ref = fb.doc(fb.db, 'pairCodes', code);
  const snap = await fb.getDoc(ref);
  if(!snap.exists()){ log('Joiner: code not found'); return; }
  const data = snap.data()||{};
  if(!data.hostPacked){ log('Joiner: code present but no host payload'); return; }

  const obj = unpack(data.hostPacked);
  try{ pc?.close(); }catch{}
  pc=newPC();
  await pc.setRemoteDescription({type:'offer', sdp: obj.s});
  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);
  if(pc.iceGatheringState!=='complete'){
    await new Promise(res=>{
      const h=()=>{ if(pc.iceGatheringState==='complete'){ pc.removeEventListener('icegatheringstatechange',h); res(); } };
      pc.addEventListener('icegatheringstatechange',h);
    });
  }
  const tiny = buildTinySDP(pc.localDescription.sdp);
  const joinPacked = pack({ r:'j', s: tiny });
  await fb.setDoc(ref, { joinPacked, joinedAt: fb.ts() }, { merge:true });
  log('Joiner: reply uploaded. Host should connect shortly.');
};

/* ================= Boot ================= */
log('Ready. Pick Host/Joiner. QR is offline; Firebase wakes up only if you choose Typed Code.');
</script>
</body>
</html>