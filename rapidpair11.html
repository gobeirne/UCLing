<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Pairing Demo â€“ QR (Offline LAN) with Reliable Chunking</title>
<style>
  body{margin:0;padding:16px;font:15px/1.4 system-ui;background:#f7f7f8;color:#222}
  h1{margin:0 0 12px;font-size:18px}
  .row{display:grid;gap:12px;grid-template-columns:1fr}
  @media(min-width:900px){.row{grid-template-columns:1fr 1fr}}
  .card{background:#fff;border:1px solid #ddd;border-radius:12px;padding:12px;margin:10px 0}
  button{padding:8px 12px;border-radius:10px;border:1px solid #ccc;background:#f5f5f5;cursor:pointer}
  button:disabled{opacity:.55;cursor:not-allowed}
  button.success{background:#e8f5e9;border-color:#4caf50}
  input,textarea{padding:6px;border:1px solid #ccc;border-radius:8px}
  textarea{width:100%;height:110px;font:12px monospace}
  .status{display:inline-block;padding:2px 8px;border-radius:999px;font-size:.9rem}
  .ok{background:#e8f5e9;color:#1b5e20}
  .warn{background:#fff8e1;color:#795548}
  .bad{background:#ffebee;color:#b71c1c}
  #log{font-size:.85rem;max-height:220px;overflow:auto;white-space:pre-wrap}
  #qrWrap{max-width:520px;position:relative}
  #qrWrap.scanned{border:3px solid #4caf50;border-radius:8px;padding:4px;animation:pulse 0.5s;}
  @keyframes pulse{0%,100%{transform:scale(1)} 50%{transform:scale(1.02)}}
  .qr-nav{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .qr-controls{display:flex;gap:6px;margin-top:8px;flex-wrap:wrap}
  #ver{color:#666;font-size:.8rem}
  .chip{display:inline-block;padding:2px 6px;margin:2px;border-radius:12px;font-size:.75rem;background:#e3f2fd;color:#1976d2}
  .chip.done{background:#c8e6c9;color:#2e7d32}
  #autoAdvance{margin-left:8px}
  label{display:inline-flex;align-items:center;gap:4px;cursor:pointer}
</style>

<!-- Local libs (put these files next to this HTML) -->
<script src="qrcode.js"></script>
<script src="pako.min.js"></script>
<script src="html5-qrcode.min.js"></script>
</head>
<body>
<h1>Pairing Demo â€“ QR (Offline LAN) with Reliable Chunking <span id="ver">v2.3</span></h1>

<div class="row">
  <div class="card">
    <h2>Role</h2>
    <button id="roleHost">Host</button>
    <button id="roleJoin">Joiner</button>
    <span id="roleBadge" class="status warn">no role</span>
  </div>
  <div class="card">
    <h2>Status</h2>
    <div>Peer: <span id="conn" class="status warn">idle</span> &nbsp; DataChannel: <span id="dc" class="status warn">-</span></div>
    <div id="log"></div>
  </div>
</div>

<div class="card">
  <h2>QR (offline, same LAN)</h2>
  <div class="row">
    <div class="card">
      <h3>Make & show my QR (Host)</h3>
      <button id="qrMake" disabled>Create my QR</button>
      <button id="qrTrouble" style="display:none;">âš  Trouble scanning? (force V4 - more chunks)</button>
      <div id="qrWrap" style="margin-top:8px"></div>
      <div id="qrNav" class="qr-nav" style="display:none;">
        <button id="qrPrev">â—€ Prev</button>
        <span id="qrIndex"></span>
        <button id="qrNext">Next â–¶</button>
        <label>
          <input type="checkbox" id="autoAdvance">
          <span>Auto-advance (3s)</span>
        </label>
      </div>
      <div class="qr-controls" style="display:none;" id="qrControlsWrap">
        <button id="qrCopy">ðŸ“‹ Copy Text</button>
        <button id="qrCopyAll" style="display:none;">ðŸ“‹ Copy All Chunks</button>
      </div>
    </div>
    <div class="card">
      <h3>Scan partner QR (Joiner)</h3>
      <button id="scanStart" disabled>Start Camera Scan</button>
      <button id="scanStop" disabled>Stop</button>
      <div id="reader" style="width:320px;max-width:100%;"></div>
      <textarea id="qrPaste" placeholder="Paste scanned textâ€¦"></textarea>
      <button id="qrApply" disabled>Apply</button>
      <div id="qrProgress" style="margin-top:6px"></div>
    </div>
  </div>
</div>

<div class="card">
  <h2>Actions</h2>
  <button id="btnBeep" disabled>Beep</button>
  <button id="btnChirp" disabled>Chirp</button>
  <button id="btnPing" disabled>Ping</button>
</div>

<script type="module">
/* ================= Helpers & UI ================= */
const $=s=>document.querySelector(s), logEl=$('#log');
function log(...a){logEl.textContent+=a.join(' ')+"\n";logEl.scrollTop=logEl.scrollHeight;}
function badge(el,t,c){el.textContent=t;el.className='status '+c;}
log('Ready. Pick Host/Joiner. QR codes optimized for LAN pairing with auto-advance & clipboard support.');

/* Base64url + deflate packers with max compression */
function b64urlFromU8(u8){
  let bin=''; for(let i=0;i<u8.length;i++) bin+=String.fromCharCode(u8[i]);
  return btoa(bin).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
}
function b64urlToU8(s){
  let b64=s.replace(/-/g,'+').replace(/_/g,'/'); while(b64.length%4) b64+='=';
  const bin=atob(b64); const u8=new Uint8Array(bin.length);
  for(let i=0;i<bin.length;i++) u8[i]=bin.charCodeAt(i);
  return u8;
}
function pack(obj){ 
  const json=JSON.stringify(obj); 
  const def=pako.deflate(json, {level: 9}); // Max compression
  return b64urlFromU8(def); 
}
function unpack(s){ const u8=b64urlToU8(s); const inf=pako.inflate(u8,{to:'string'}); return JSON.parse(inf); }

/* Extract minimal SDP info needed for datachannel-only LAN connection */
function extractMinimalSDP(sdp, type){
  const lines = sdp.split('\r\n');
  const minimal = {
    t: type === 'offer' ? 'o' : 'a', // single char for type
    u: '', // ufrag
    p: '', // pwd
    f: '', // fingerprint
    s: '', // setup
    m: '', // mid
    c: []  // candidates (host only)
  };
  
  let sctpPort = '';
  
  for(const line of lines){
    if(line.startsWith('a=ice-ufrag:')) minimal.u = line.split(':')[1];
    else if(line.startsWith('a=ice-pwd:')) minimal.p = line.split(':')[1];
    else if(line.startsWith('a=fingerprint:')) {
      // Store only the hash part, we know it's sha-256
      minimal.f = line.split(' ')[1];
    }
    else if(line.startsWith('a=setup:')) minimal.s = line.split(':')[1];
    else if(line.startsWith('a=mid:')) minimal.m = line.split(':')[1];
    else if(line.startsWith('a=sctp-port:')) sctpPort = line.split(':')[1];
    else if(line.startsWith('a=candidate:') && line.includes('typ host')){
      // Only keep essential parts of host candidates
      // Format: foundation component protocol priority ip port typ host
      const parts = line.substring(12).split(' ');
      // Store as: foundation:component:protocol:ip:port (minimal)
      minimal.c.push(`${parts[0]}:${parts[1]}:${parts[2]}:${parts[4]}:${parts[5]}`);
    }
  }
  
  // Add sctp port if found (usually 5000)
  if(sctpPort) minimal.sp = sctpPort;
  
  return minimal;
}

/* Reconstruct full SDP from minimal datachannel-only info */
function reconstructSDP(minimal){
  const type = minimal.t === 'o' ? 'offer' : 'answer';
  const isOffer = minimal.t === 'o';
  
  let sdp = `v=0\r\n`;
  sdp += `o=- ${Date.now()} 2 IN IP4 127.0.0.1\r\n`;
  sdp += `s=-\r\n`;
  sdp += `t=0 0\r\n`;
  sdp += `a=group:BUNDLE ${minimal.m}\r\n`;
  sdp += `a=msid-semantic: WMS\r\n`;
  
  // Data channel media line (port 9 is standard placeholder)
  sdp += `m=application 9 UDP/DTLS/SCTP webrtc-datachannel\r\n`;
  sdp += `c=IN IP4 0.0.0.0\r\n`;
  sdp += `a=ice-ufrag:${minimal.u}\r\n`;
  sdp += `a=ice-pwd:${minimal.p}\r\n`;
  sdp += `a=ice-options:trickle\r\n`;
  sdp += `a=fingerprint:sha-256 ${minimal.f}\r\n`;
  sdp += `a=setup:${minimal.s}\r\n`;
  sdp += `a=mid:${minimal.m}\r\n`;
  
  // SCTP config (use provided port or default 5000)
  const sctpPort = minimal.sp || '5000';
  sdp += `a=sctp-port:${sctpPort}\r\n`;
  sdp += `a=max-message-size:262144\r\n`; // Standard 256KB
  
  // Reconstruct candidates from compact format
  if(minimal.c && minimal.c.length > 0){
    for(const compactCand of minimal.c){
      const parts = compactCand.split(':');
      if(parts.length >= 5){
        const [foundation, component, protocol, ip, port] = parts;
        // Rebuild full candidate line with standard priority calculation
        const priority = 2130706431; // Standard host priority
        sdp += `a=candidate:${foundation} ${component} ${protocol} ${priority} ${ip} ${port} typ host generation 0 network-id 1\r\n`;
      }
    }
  }
  
  log('Reconstructed SDP:', sdp.substring(0, 200) + '...');
  return sdp;
}

/* ================= Role UI ================= */
let role=null, hostQRShown=false;
function setRole(r){
  role=r; hostQRShown=false;
  badge($('#roleBadge'), r==='host'?'Host':'Joiner','ok');
  if(r==='host'){
    $('#qrMake').disabled=false;
    // Host can't scan until they've shown their QR
    $('#scanStart').disabled=true; $('#scanStop').disabled=true; $('#qrApply').disabled=true;
  }else{
    $('#qrMake').disabled=true;
    $('#scanStart').disabled=false; $('#scanStop').disabled=false; $('#qrApply').disabled=false;
  }
}
$('#roleHost').onclick=()=>setRole('host');
$('#roleJoin').onclick=()=>setRole('join');

/* ================= WebRTC ================= */
let pc=null, dc=null;
function newPC(){
  const cfg={iceServers:[]}; // offline LAN host candidates only (fast)
  const p=new RTCPeerConnection(cfg);
  p.onicegatheringstatechange = ()=>log('gathering:', p.iceGatheringState);
  p.oniceconnectionstatechange = ()=>log('ice:', p.iceConnectionState);
  p.onsignalingstatechange    = ()=>log('signal:', p.signalingState);
  p.onconnectionstatechange   = ()=>{
    const s=p.connectionState; badge($('#conn'),s, s==='connected'?'ok':(s==='failed'||s==='disconnected'?'bad':'warn'));
    const up = s==='connected'; ['#btnBeep','#btnChirp','#btnPing'].forEach(id=>$(id).disabled=!up);
  };
  p.ondatachannel = e=>{ dc=e.channel; attachDC(); };
  return p;
}
function attachDC(){
  if(!dc) return;
  badge($('#dc'),dc.readyState, dc.readyState==='open'?'ok':'warn');
  dc.onopen  = ()=>badge($('#dc'),'open','ok');
  dc.onclose = ()=>badge($('#dc'),'closed','bad');
  dc.onmessage = e=>log('RX', e.data);
}
function send(m){ if(dc&&dc.readyState==='open') dc.send(m); }
$('#btnBeep').onclick = ()=>send('BEEP');
$('#btnChirp').onclick= ()=>send('CHIRP');
$('#btnPing').onclick = ()=>send('PING');

/* ================= QR Encode/Decode ================= */
const QR_PREFIX='UCP1|'; // UCP v1 framing: "UCP1|<total>|<index>|<payload>"
const NAV_SCALE=6;       // visual scale for SVG

function tryRenderQR(text, typeNumber, ecc='M'){
  const q = qrcode(typeNumber, ecc);
  q.addData(text);
  q.make(); // will throw "code length overflow" if it doesn't fit
  return q.createSvgTag(NAV_SCALE);
}
function renderDenseOrThrow(s){
  // typeNumber=0 lets qrcode.js auto-pick a version; can still throw if insanely huge
  return tryRenderQR(s, 0, 'M');
}

/* Calculate max payload for a given QR version with our framing overhead */
function maxPayloadForVersion(ver, parts, ecc='M'){
  // QR capacities (alphanumeric mode, Medium ECC) - approximations
  const capacities = {
    4: 114, 6: 180, 8: 250, 10: 346, 12: 434, 14: 538, 16: 666,
    18: 778, 20: 906, 24: 1174, 28: 1502, 32: 1853, 36: 2132, 40: 2409
  };
  
  const maxChars = capacities[ver] || 100;
  // Account for framing: "UCP1|<total>|<index>|"
  const overhead = QR_PREFIX.length + String(parts).length + 1 + String(parts).length + 1;
  return Math.max(0, maxChars - overhead);
}

/* Dynamic split with true V4 enforcement when requested */
function makeChunks(packed, forceV4=false){
  if(forceV4){
    // FORCE V4: Keep increasing part count until all chunks fit in V4
    const ver = 4;
    const maxParts = 20; // reasonable upper limit
    
    for(let parts=2; parts<=maxParts; parts++){
      const maxPay = maxPayloadForVersion(ver, parts);
      const size = Math.ceil(packed.length / parts);
      
      if(size <= maxPay){
        // All chunks will fit!
        const out = [];
        for(let i=0; i<parts; i++){
          const slice = packed.slice(i*size, Math.min((i+1)*size, packed.length));
          const framed = `${QR_PREFIX}${parts}|${i+1}|${slice}`;
          try{
            tryRenderQR(framed, ver, 'M');
            out.push({ver, str: framed});
          }catch(e){
            // Should not happen if our math is right, but safety check
            break;
          }
        }
        if(out.length === parts) return out;
      }
    }
    throw Error(`Payload too large for V4 even with ${maxParts} parts`);
    
  } else {
    // AUTO MODE: Try minimal parts with version escalation
    const versions = [4,6,8,10,12,14,16,18,20,24,28,32,36,40];
    for(let parts=2; parts<=4; parts++){
      for(const ver of versions){
        const size = Math.ceil(packed.length / parts);
        const out = [];
        let ok = true;
        for(let i=0; i<parts; i++){
          const slice = packed.slice(i*size, Math.min((i+1)*size, packed.length));
          const framed = `${QR_PREFIX}${parts}|${i+1}|${slice}`;
          try{
            tryRenderQR(framed, ver, 'M');
            out.push({ver, str: framed});
          }catch(e){
            ok=false; break;
          }
        }
        if(ok) return out;
      }
    }
    throw Error('Payload too large even for 4 parts at high versions');
  }
}

let qrPacked='', qrChunks=[], qrIdx=0, chunkMode=false, autoTimer=null;

function showDense(){
  try{
    const svg = renderDenseOrThrow(qrPacked);
    $('#qrWrap').innerHTML = svg;
    $('#qrNav').style.display='none';
    $('#qrTrouble').style.display='inline';
    $('#qrControlsWrap').style.display='flex';
    $('#qrCopyAll').style.display='none';
    chunkMode=false;
    log(`Dense QR shown (auto). Payload length: ${qrPacked.length}`);
  }catch(e){
    log('Dense overflow, preparing chunks automaticallyâ€¦', e.message||e);
    // Fallback immediately to chunking with version escalation
    qrChunks = makeChunks(qrPacked, /*forceV4*/ false);
    qrIdx=0; chunkMode=true; showChunk();
    $('#qrTrouble').style.display='inline';
  }
}

function showChunk(){
  if(!qrChunks.length){ log('No chunks to show'); return; }
  const {ver,str} = qrChunks[qrIdx];
  try{
    const svg = tryRenderQR(str, ver, 'M');
    $('#qrWrap').innerHTML = svg;
    $('#qrIndex').textContent = `${qrIdx+1}/${qrChunks.length} (V${ver})`;
    $('#qrNav').style.display='flex';
    $('#qrControlsWrap').style.display='flex';
    $('#qrCopyAll').style.display='inline-block';
    
    // Start auto-advance if enabled
    if($('#autoAdvance').checked){
      clearTimeout(autoTimer);
      autoTimer = setTimeout(()=>{
        qrIdx = (qrIdx+1) % qrChunks.length;
        showChunk();
      }, 3000);
    }
  }catch(e){
    log('Chunk render error:', e.message||e);
  }
}

$('#qrPrev').onclick=()=>{ 
  clearTimeout(autoTimer);
  qrIdx=(qrIdx-1+qrChunks.length)%qrChunks.length; 
  showChunk(); 
};
$('#qrNext').onclick=()=>{ 
  clearTimeout(autoTimer);
  qrIdx=(qrIdx+1)%qrChunks.length; 
  showChunk(); 
};
$('#autoAdvance').onchange=()=>{
  if(!$('#autoAdvance').checked) clearTimeout(autoTimer);
  else if(chunkMode) showChunk(); // restart timer
};

/* Copy to clipboard */
async function copyToClipboard(text){
  try{
    await navigator.clipboard.writeText(text);
    return true;
  }catch(e){
    // Fallback for older browsers
    const ta = document.createElement('textarea');
    ta.value = text;
    ta.style.position = 'fixed';
    ta.style.opacity = '0';
    document.body.appendChild(ta);
    ta.select();
    const ok = document.execCommand('copy');
    document.body.removeChild(ta);
    return ok;
  }
}

$('#qrCopy').onclick = async ()=>{
  const text = chunkMode ? qrChunks[qrIdx].str : qrPacked;
  const ok = await copyToClipboard(text);
  if(ok){
    $('#qrCopy').textContent = 'âœ“ Copied!';
    $('#qrCopy').classList.add('success');
    setTimeout(()=>{
      $('#qrCopy').textContent = 'ðŸ“‹ Copy Text';
      $('#qrCopy').classList.remove('success');
    }, 2000);
    log('Copied to clipboard');
  }else{
    log('Copy failed - please select and copy manually');
  }
};

$('#qrCopyAll').onclick = async ()=>{
  const allText = qrChunks.map(c=>c.str).join('\n---\n');
  const ok = await copyToClipboard(allText);
  if(ok){
    $('#qrCopyAll').textContent = 'âœ“ All Copied!';
    $('#qrCopyAll').classList.add('success');
    setTimeout(()=>{
      $('#qrCopyAll').textContent = 'ðŸ“‹ Copy All Chunks';
      $('#qrCopyAll').classList.remove('success');
    }, 2000);
    log('All chunks copied to clipboard');
  }else{
    log('Copy failed');
  }
};

/* ================= Host: create offer & QR ================= */
$('#qrMake').onclick = async ()=>{
  if(role!=='host'){ alert('Pick role Host first'); return; }
  // Fresh PC
  try{ pc?.close(); }catch{}
  pc=newPC();
  dc=pc.createDataChannel('x'); attachDC();

  await pc.setLocalDescription(await pc.createOffer());
  log('Host setLocalDescription(offer). Waiting for ICE completeâ€¦');

  if(pc.iceGatheringState!=='complete'){
    await new Promise(res=>{
      const h=()=>{ if(pc.iceGatheringState==='complete'){ pc.removeEventListener('icegatheringstatechange',h); res(); } };
      pc.addEventListener('icegatheringstatechange',h);
    });
  }
  
  // Trim and pack SDP
  const minimalSDP = extractMinimalSDP(pc.localDescription.sdp, pc.localDescription.type);
  qrPacked = pack({ role:'host', sdp: minimalSDP });
  
  log(`Minimal SDP extracted. Original: ${pc.localDescription.sdp.length}, Packed: ${qrPacked.length}`);
  
  // Show dense first; user can force split with "Trouble scanning?"
  showDense();
  
  // Enable scanning for Host to receive Joiner's reply
  hostQRShown = true;
  $('#scanStart').disabled=false; 
  $('#scanStop').disabled=false; 
  $('#qrApply').disabled=false;
  log('âœ“ Show this QR to Joiner. Then prepare to scan their reply QR!');
};

/* Force V4 handler - strictly enforces V4, increases chunk count as needed */
$('#qrTrouble').onclick = ()=>{
  if(!qrPacked){ log('No payload to split yet.'); return; }
  clearTimeout(autoTimer);
  try{
    qrChunks = makeChunks(qrPacked, /*forceV4*/ true);
    qrIdx=0; chunkMode=true; showChunk();
    log(`Forced V4: ${qrChunks.length} parts, easier to scan!`);
  }catch(e){
    log('V4 split failed:', e.message||e);
  }
};

/* ================= Joiner: scan/apply & reply ================= */
let scanner=null;
function stopScanner(){
  if(!scanner) return;
  scanner.stop().then(()=>scanner.clear()).catch(()=>{}); scanner=null;
}
let asm={total:0, got:new Set(), parts:[]};
function resetAsm(){ 
  asm={total:0,got:new Set(),parts:[]}; 
  $('#qrProgress').innerHTML=''; 
}

function updateProgress(){
  if(!asm.total) return;
  const chips = [];
  for(let i=1; i<=asm.total; i++){
    const done = asm.got.has(i);
    chips.push(`<span class="chip ${done?'done':''}">${i}</span>`);
  }
  $('#qrProgress').innerHTML = `Progress: ${chips.join('')} (${asm.got.size}/${asm.total})`;
}

function absorb(text){
  // Visual feedback
  $('#qrWrap').classList.add('scanned');
  setTimeout(()=>$('#qrWrap').classList.remove('scanned'), 500);
  
  // Chunks?
  if(text.startsWith(QR_PREFIX)){
    const rest=text.slice(QR_PREFIX.length);
    const p1=rest.indexOf('|'); const p2=rest.indexOf('|',p1+1);
    if(p1<0||p2<0) return;
    const total=+rest.slice(0,p1), index=+rest.slice(p1+1,p2), data=rest.slice(p2+1);
    if(!asm.total){ asm.total=total; asm.parts=Array(total).fill(''); }
    
    if(!asm.got.has(index)){
      asm.got.add(index); 
      asm.parts[index-1]=data;
      log(`âœ“ Scanned chunk ${index}/${total}`);
    }
    
    updateProgress();
    
    if(asm.got.size===asm.total){
      const packed = asm.parts.join('');
      log('ðŸŽ‰ All chunks received!');
      resetAsm();
      applyPacked(packed);
    }
  }else{
    log('âœ“ Scanned single QR');
    applyPacked(text);
  }
}

async function applyPacked(packed){
  try{
    const obj = unpack(packed); // {role:'host'|'join', sdp: minimal object}
    log('Unpacked payload:', JSON.stringify(obj).substring(0, 100) + '...');
    
    // Ensure we have a PC
    if(!pc){ pc=newPC(); }

    if(role==='join' && obj.role==='host'){
      // We received Host's offer â€“ reconstruct and create answer
      const fullSDP = reconstructSDP(obj.sdp);
      log('Reconstructed SDP length:', fullSDP.length);
      const sdpType = obj.sdp.t === 'o' ? 'offer' : 'answer';
      log('Setting remote description type:', sdpType);
      await pc.setRemoteDescription({type: sdpType, sdp: fullSDP});
      await pc.setLocalDescription(await pc.createAnswer());
      if(pc.iceGatheringState!=='complete'){
        await new Promise(res=>{
          const h=()=>{ if(pc.iceGatheringState==='complete'){ pc.removeEventListener('icegatheringstatechange',h); res(); } };
          pc.addEventListener('icegatheringstatechange',h);
        });
      }
      
      // Pack minimal reply
      const minimalSDP = extractMinimalSDP(pc.localDescription.sdp, pc.localDescription.type);
      const replyPacked = pack({ role:'join', sdp: minimalSDP });
      qrPacked = replyPacked;
      stopScanner();
      // Dense first; user can force split if needed
      showDense();
      log('Joiner: reply ready â€“ show QR to Host');

    } else if(role==='host' && obj.role==='join'){
      // We received Joiner's answer â€“ reconstruct and apply
      if(!pc){ pc=newPC(); }
      const fullSDP = reconstructSDP(obj.sdp);
      await pc.setRemoteDescription({type: obj.sdp.t === 'o' ? 'offer' : 'answer', sdp: fullSDP});
      log('Host: applied joiner answer');
      stopScanner();

    } else {
      log('ERR Role mismatch or unexpected payload. You picked:', role, 'payload role:', obj.role);
    }
  }catch(e){
    log('ERR applyPacked', e.message||e);
  }
}

/* Scan controls */
$('#scanStart').onclick=()=>{
  resetAsm();
  try{
    scanner = new Html5Qrcode("reader");
    scanner.start({facingMode:"environment"},{fps:10,qrbox:240}, txt=>absorb(txt), _err=>{})
      .catch(err=>log('scan ERR', err));
  }catch(e){ log('scanner init ERR', e.message||e); }
};
$('#scanStop').onclick=()=>{ stopScanner(); resetAsm(); };

$('#qrApply').onclick=()=>{ 
  const t=$('#qrPaste').value.trim(); 
  if(t){ 
    absorb(t); 
    $('#qrPaste').value=''; 
  } 
};

</script>
</body>
</html>
