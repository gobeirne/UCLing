<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Rapid Pair — LAN QR (Tiny)</title>
<style>
  body{margin:0;padding:16px;font:15px/1.4 system-ui;background:#f7f7f8;color:#222}
  h1{margin:0 0 12px;font-size:18px}
  .row{display:grid;gap:12px;grid-template-columns:1fr}
  @media(min-width:900px){.row{grid-template-columns:1fr 1fr}}
  .card{background:#fff;border:1px solid #ddd;border-radius:12px;padding:12px;margin:10px 0}
  button{padding:8px 12px;border-radius:10px;border:1px solid #ccc;background:#f5f5f5;cursor:pointer}
  button:disabled{opacity:.55;cursor:not-allowed}
  input,textarea{padding:6px;border:1px solid #ccc;border-radius:8px}
  textarea{width:100%;height:110px;font:12px monospace}
  .status{display:inline-block;padding:2px 8px;border-radius:999px;font-size:.9rem}
  .ok{background:#e8f5e9;color:#1b5e20} .warn{background:#fff8e1;color:#795548} .bad{background:#ffebee;color:#b71c1c}
  #log{font-size:.85rem;max-height:220px;overflow:auto;white-space:pre-wrap}
  #qrWrap{max-width:420px}
  .qr-nav{display:flex;gap:8px;align-items:center}
  #ver{color:#666;font-size:.8rem}
  .muted{color:#666;font-size:.9rem}
</style>
<script src="qrcode.js"></script>
<script src="pako.min.js"></script>
<script src="html5-qrcode.min.js"></script>
</head>
<body>
<h1>Rapid Pair — LAN QR (Tiny) <span id="ver">v2.0</span></h1>

<div class="row">
  <div class="card">
    <h2>Role</h2>
    <button id="roleHost">Host</button>
    <button id="roleJoin">Joiner</button>
    <span id="roleBadge" class="status warn">no role</span>
    <div class="muted" style="margin-top:8px">For **instant** same-LAN pairing. No cloud. If scanning struggles, enable “Robust ECC” or 4-chunk fallback.</div>
  </div>
  <div class="card">
    <h2>Status</h2>
    <div>Peer: <span id="conn" class="status warn">idle</span> &nbsp; DataChannel: <span id="dc" class="status warn">-</span></div>
    <div id="log"></div>
  </div>
</div>

<div class="card">
  <h2>QR (offline, same LAN)</h2>
  <div class="row">
    <div class="card">
      <h3>Make & show my QR</h3>
      <button id="qrMake" disabled>Create my QR</button>
      <button id="qrTrouble" style="display:none;">⚠ Trouble scanning? (4 fat codes)</button>
      <label style="display:block;margin-top:6px"><input type="checkbox" id="robustECC"> Robust (ECC=M)</label>
      <div id="qrWrap" style="margin-top:8px"></div>
      <div id="qrNav" class="qr-nav" style="display:none;">
        <button id="qrPrev">◀ Prev</button>
        <span id="qrIndex"></span>
        <button id="qrNext">Next ▶</button>
      </div>
    </div>
    <div class="card">
      <h3>Scan partner QR</h3>
      <button id="scanStart" disabled>Start Camera Scan</button>
      <button id="scanStop" disabled>Stop</button>
      <div id="reader" style="width:320px;max-width:100%;"></div>
      <textarea id="qrPaste" placeholder="Paste scanned text…"></textarea>
      <button id="qrApply" disabled>Apply</button>
      <div id="qrProgress" class="muted" style="margin-top:6px"></div>
    </div>
  </div>
</div>

<div class="card">
  <h2>Actions</h2>
  <button id="btnBeep" disabled>Beep</button>
  <button id="btnChirp" disabled>Chirp</button>
  <button id="btnPing" disabled>Ping</button>
</div>

<script>
/* ========== Helpers ========== */
const $=s=>document.querySelector(s), logEl=$('#log');
function log(...a){logEl.textContent+=a.join(' ')+"\n";logEl.scrollTop=logEl.scrollHeight;}
function badge(el,t,c){el.textContent=t;el.className='status '+c;}

function b64url(u8){
  let bin=''; for(let i=0;i<u8.length;i++) bin+=String.fromCharCode(u8[i]);
  const b64=btoa(bin); let out='';
  for(let i=0;i<b64.length;i++){const ch=b64[i];
    if(ch==='+') out+='-'; else if(ch==='/') out+='_'; else if(ch==='='){} else out+=ch;
  } return out;
}
function unb64url(s){
  let b64=''; for(let i=0;i<s.length;i++){const ch=s[i];
    if(ch==='-') b64+='+'; else if(ch==='_') b64+='/'; else b64+=ch;
  } while(b64.length%4) b64+='=';
  const bin=atob(b64); const u8=new Uint8Array(bin.length);
  for(let i=0;i<bin.length;i++) u8[i]=bin.charCodeAt(i); return u8;
}
function pack(o){ return b64url(pako.deflate(JSON.stringify(o))); }
function unpack(s){ return JSON.parse(pako.inflate(unb64url(s), {to:'string'})); }

/* ========== Role UI ========== */
let role=null;
function setRole(r){
  role=r; badge($('#roleBadge'), r==='host'?'Host':'Joiner','ok');
  if(r==='host'){
    $('#qrMake').disabled=false;
    $('#scanStart').disabled=false; $('#scanStop').disabled=false; $('#qrApply').disabled=false;
    log('Host: press "Create my QR" then the Joiner scans it.');
  }else{
    $('#qrMake').disabled=true; // Joiner creates their QR only after scanning host
    $('#scanStart').disabled=false; $('#scanStop').disabled=false; $('#qrApply').disabled=false;
    log('Joiner: scan Host QR first, then your reply QR will be generated automatically.');
  }
}
$('#roleHost').onclick=()=>setRole('host');
$('#roleJoin').onclick=()=>setRole('join');

/* ========== WebRTC (LAN-only) ========== */
let pc,dc;

function newPC(){
  const p = new RTCPeerConnection({iceServers:[]}); // host candidates only
  p.onicegatheringstatechange = ()=>log('gathering:', p.iceGatheringState);
  p.oniceconnectionstatechange = ()=>log('ice:', p.iceConnectionState);
  p.onsignalingstatechange = ()=>log('signal:', p.signalingState);
  p.onconnectionstatechange = ()=>{
    const s=p.connectionState; badge($('#conn'),s, s==='connected'?'ok':(s==='failed'||s==='disconnected'?'bad':'warn'));
    const up=s==='connected'; ['#btnBeep','#btnChirp','#btnPing'].forEach(id=>$(id).disabled=!up);
  };
  p.ondatachannel = e=>{ dc=e.channel; attachDC(); };
  return p;
}
function attachDC(){
  badge($('#dc'),dc.readyState, dc.readyState==='open'?'ok':'warn');
  dc.onopen = ()=>badge($('#dc'),'open','ok');
  dc.onclose= ()=>badge($('#dc'),'closed','bad');
  dc.onmessage=e=>log('RX', e.data);
}
function send(m){ if(dc&&dc.readyState==='open') dc.send(m); }
$('#btnBeep').onclick=()=>send('BEEP');
$('#btnChirp').onclick=()=>send('CHIRP');
$('#btnPing').onclick =()=>send('PING');

/* ========== Tiny SDP pack/unpack (strip candidates) ========== */
// Keep essential lines; drop a=candidate, then add ONE synthetic host candidate from ip:port
function extractIpPortFromCandidateLine(line){
  // a=candidate:... <ip> <port> typ host
  const parts = line.trim().split(/\s+/);
  return { ip: parts[4], port: parseInt(parts[5],10) };
}
function firstHostCandidate(sdp){
  const lines = sdp.split(/\r?\n/);
  for(const l of lines){
    if(l.startsWith('a=candidate:') && / typ host(\s|$)/.test(l) && /\sudp\s/.test(l)) return extractIpPortFromCandidateLine(l);
  }
  return null;
}
function stripCandidates(sdp){
  return sdp.split(/\r?\n/).filter(l=>!l.startsWith('a=candidate:') && l!=='a=end-of-candidates').join('\r\n');
}
function rebuildCandidate(ip, port){
  // constants are fine for LAN host
  return `a=candidate:0 1 udp 2122252543 ${ip} ${port} typ host`;
}
function injectCandidateAndEnd(sdp, ip, port){
  const lines = sdp.split(/\r?\n/);
  // Put candidate near the m=application section (after mid)
  let midIdx = lines.findIndex(l=>l.startsWith('a=mid:'));
  if(midIdx<0) midIdx = lines.findIndex(l=>l.startsWith('m=application'));
  const cand = rebuildCandidate(ip, port);
  lines.splice(midIdx+1, 0, cand, 'a=end-of-candidates');
  return lines.join('\r\n');
}

/* QR payload format:
   { role: "host"|"join", t:"offer"|"answer", ip:"10.0.0.5", port:53282, sdpMini:"<SDP without candidates>" }
*/

/* ========== QR UI + logic ========== */
const QR_PREFIX='RP1|';
const CHUNK_COUNT=4; // fallback only (usually not needed now)
const SCALE_SINGLE=5, SCALE_CHUNK=8;

function renderQR(txt, ecc){
  // Force QR version small (2 or 4) by content size; qrcode.js chooses minimal version for the content.
  const q=qrcode(0, ecc); // 0 = auto version (keeps it tiny with our tiny payload)
  q.addData(txt); q.make();
  return q.createSvgTag($('#robustECC').checked?'5':'5'); // scale visually (not QR version)
}

let qrPacked='', qrChunks=[], qrMode='single', qrIdx=0;

function showQR(){
  const ecc = $('#robustECC').checked ? 'M' : 'L';
  const wrap=$('#qrWrap');
  if(qrMode==='single'){
    wrap.innerHTML = renderQR(qrPacked, ecc);
    $('#qrNav').style.display='none';
  }else{
    const payload = `${QR_PREFIX}${qrChunks.length}|${qrIdx+1}|${qrChunks[qrIdx]}`;
    wrap.innerHTML = renderQR(payload, ecc);
    $('#qrIndex').textContent = `${qrIdx+1}/${qrChunks.length}`;
    $('#qrNav').style.display='flex';
  }
}
function split4(s){ const sz=Math.ceil(s.length/CHUNK_COUNT); return Array.from({length:CHUNK_COUNT},(_,i)=>s.slice(i*sz,(i+1)*sz)); }
$('#qrPrev').onclick=()=>{ qrIdx=(qrIdx-1+qrChunks.length)%qrChunks.length; showQR(); };
$('#qrNext').onclick=()=>{ qrIdx=(qrIdx+1)%qrChunks.length; showQR(); };
$('#qrTrouble').onclick=()=>{ qrChunks=split4(qrPacked); qrIdx=0; qrMode='multi'; showQR(); };

/* Scanner */
let scanner=null, scannerActive=false;
function stopScanner(){
  if(scannerActive && scanner){
    scanner.stop().then(()=>scanner.clear()).catch(()=>{}).finally(()=>{scanner=null; scannerActive=false; $('#scanStop').disabled=true;});
  }
}
$('#scanStart').onclick=()=>{
  try{
    scanner = new Html5Qrcode("reader");
    scanner.start(
      {facingMode:"environment"},
      {fps:10, qrbox:240},
      txt => { absorb(txt); /* auto-stop handled in absorb on success */ },
      _err => {}
    ).then(()=>{ scannerActive=true; $('#scanStop').disabled=false; });
  }catch(e){ log('scanner init ERR', e.message||e); }
};
$('#scanStop').onclick=()=>stopScanner();

/* Assemble multi-QR (rare) */
let asm={total:0, got:new Set(), parts:[]};
function resetAsm(){ asm={total:0,got:new Set(),parts:[]}; $('#qrProgress').textContent=''; }
function absorb(text){
  if(text.startsWith(QR_PREFIX)){
    const rest=text.slice(QR_PREFIX.length);
    const p1=rest.indexOf('|'), p2=rest.indexOf('|',p1+1);
    if(p1<0||p2<0) return;
    const total=+rest.slice(0,p1), index=+rest.slice(p1+1,p2), data=rest.slice(p2+1);
    if(!asm.total){ asm.total=total; asm.parts=Array(total).fill(''); }
    asm.got.add(index); asm.parts[index-1]=data;
    $('#qrProgress').textContent = `Got parts: ${[...asm.got].sort().join(', ')} / ${asm.total}`;
    if(asm.got.size===asm.total){
      const packed=asm.parts.join('');
      resetAsm(); applyPacked(packed, true);
    }
  } else {
    applyPacked(text, true);
  }
}
$('#qrApply').onclick=()=>{ const t=$('#qrPaste').value.trim(); if(t){ absorb(t); $('#qrPaste').value=''; } };

/* ========== Host/Joiner QR flows ========== */
// Host: create offer, wait for FIRST host candidate -> make tiny QR (offer)
// Joiner: scan host QR -> setRemote(offer) -> create answer -> wait FIRST host candidate -> make tiny QR (answer)
// Host: scan joiner QR -> setRemote(answer) -> connected

async function makeHostQR(){
  pc = newPC();
  dc = pc.createDataChannel('x'); attachDC();

  let done=false, ipPort=null;

  pc.onicecandidate = e=>{
    if(done) return;
    if(e.candidate && / typ host/.test(e.candidate.candidate) && / udp /.test(e.candidate.candidate)){
      const parts=e.candidate.candidate.trim().split(/\s+/);
      ipPort = { ip: parts[4], port: parseInt(parts[5],10) };
      finalize();
    }
  };

  await pc.setLocalDescription(await pc.createOffer({iceRestart:false}));
  // try to be "instant" — if host cand already baked into SDP (sometimes is), use it; else wait onicecandidate fired
  ipPort = ipPort || firstHostCandidate(pc.localDescription.sdp);
  if(ipPort) finalize();

  function finalize(){
    if(done) return; done=true;
    const sdpMini = stripCandidates(pc.localDescription.sdp);
    const payload = { role:'host', t:'offer', ip:ipPort.ip, port:ipPort.port, sdpMini };
    qrPacked = pack(payload);
    qrMode='single'; $('#qrTrouble').style.display='inline'; showQR();
    log('Host: QR ready (offer, tiny). Show to Joiner.');
  }
}

async function onGotHostQR(obj){
  // Joiner applying Host's Offer (tiny)
  if(role!=='join'){ alert('Set role to Joiner.'); return; }
  if(pc && pc.signalingState!=='stable'){ try{pc.close();}catch{} }
  pc = newPC();

  // Rebuild full offer
  const offerFull = injectCandidateAndEnd(obj.sdpMini, obj.ip, obj.port);
  await pc.setRemoteDescription({type:'offer', sdp:offerFull});

  // Create DC implicitly when host created — joiner gets it via ondatachannel
  let done=false, ipPort=null;
  pc.onicecandidate = e=>{
    if(done) return;
    if(e.candidate && / typ host/.test(e.candidate.candidate) && / udp /.test(e.candidate.candidate)){
      const parts=e.candidate.candidate.trim().split(/\s+/);
      ipPort = { ip: parts[4], port: parseInt(parts[5],10) };
      finalize();
    }
  };

  await pc.setLocalDescription(await pc.createAnswer());
  ipPort = ipPort || firstHostCandidate(pc.localDescription.sdp);
  if(ipPort) finalize();

  function finalize(){
    if(done) return; done=true;
    const sdpMini = stripCandidates(pc.localDescription.sdp);
    const payload = { role:'join', t:'answer', ip:ipPort.ip, port:ipPort.port, sdpMini };
    qrPacked = pack(payload);
    qrMode='single'; $('#qrTrouble').style.display='inline'; showQR();
    log('Joiner: reply QR ready (answer). Show to Host.');
  }
}

async function onGotJoinerQR(obj){
  // Host applying Joiner's Answer (tiny)
  if(role!=='host'){ alert('Set role to Host.'); return; }
  const answerFull = injectCandidateAndEnd(obj.sdpMini, obj.ip, obj.port);
  await pc.setRemoteDescription({type:'answer', sdp:answerFull});
  log('Host: Answer applied. Connecting…');
}

/* Apply packed (from scan/paste) */
async function applyPacked(packed, stopCamOnSuccess){
  try{
    const obj = unpack(packed); // {role,t,ip,port,sdpMini}
    if(!obj || !obj.role || !obj.t || !obj.ip || !obj.port || !obj.sdpMini){ log('ERR: bad payload'); return; }

    if(obj.t==='offer' && obj.role==='host'){
      await onGotHostQR(obj);
      if(stopCamOnSuccess) stopScanner();
    }else if(obj.t==='answer' && obj.role==='join'){
      await onGotJoinerQR(obj);
      if(stopCamOnSuccess) stopScanner();
    }else{
      alert('Role/step mismatch. Host must present Offer first, then Joiner presents Answer.');
    }
  }catch(e){
    log('ERR applyPacked', e.message||e);
  }
}

/* Buttons */
$('#qrMake').onclick=async()=>{
  if(!role){ alert('Pick role first'); return; }
  if(role==='host'){
    await makeHostQR();
  }else{
    alert('Joiner QR is created automatically after scanning Host.');
  }
};

window.addEventListener('load', ()=>{
  log('Ready. Pick Host/Joiner. For instant LAN, use QR on the same network.');
  $('#scanStart').disabled=false; $('#scanStop').disabled=false; $('#qrApply').disabled=false;
});

/* ========== End ========== */
</script>
</body>
</html>
