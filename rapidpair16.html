<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Rapid Pair — Code or QR (same payload) + onSnapshot</title>
<style>
  body{margin:0;padding:16px;font:15px/1.45 system-ui,Segoe UI,Roboto;background:#f7f7f8;color:#222}
  h1{margin:0 0 12px;font-size:18px}
  .row{display:grid;gap:12px;grid-template-columns:1fr}
  @media(min-width:900px){.row{grid-template-columns:1fr 1fr}}
  .card{background:#fff;border:1px solid #ddd;border-radius:12px;padding:12px;margin:10px 0}
  button{padding:8px 12px;border-radius:10px;border:1px solid #ccc;background:#f5f5f5;cursor:pointer}
  button:disabled{opacity:.55;cursor:not-allowed}
  input,textarea{padding:6px;border:1px solid #ccc;border-radius:8px}
  textarea{width:100%;height:110px;font:12px monospace}
  .status{display:inline-block;padding:2px 8px;border-radius:999px;font-size:.9rem}
  .ok{background:#e8f5e9;color:#1b5e20}
  .warn{background:#fff8e1;color:#795548}
  .bad{background:#ffebee;color:#b71c1c}
  #log{font-size:.85rem;max-height:260px;overflow:auto;white-space:pre-wrap}
  .muted{color:#666;font-size:.9rem}
  #qrWrap{max-width:520px}
  .qr-nav{display:flex;gap:8px;align-items:center}
  code.small{font-size:12px;background:#f0f0f0;padding:2px 6px;border-radius:6px}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace}
</style>
<!-- keep these local (as you had) -->
<script src="qrcode.js"></script>
<script src="html5-qrcode.min.js"></script>
</head>
<body>
<h1>Rapid Pair — Code or QR (same payload) <span class="muted">onSnapshot + TURN-opt</span></h1>

<div class="row">
  <div class="card">
    <h2>Role</h2>
    <button id="roleHost">Host</button>
    <button id="roleJoin">Joiner</button>
    <span id="roleBadge" class="status warn">no role</span>
    <div class="muted" id="tip">Ready. Pick Host/Joiner. Dense QR or typed code — both carry the same payload.</div>
  </div>
  <div class="card">
    <h2>Status</h2>
    <div>Peer: <span id="conn" class="status warn">idle</span> &nbsp; DataChannel: <span id="dc" class="status warn">-</span></div>
    <div id="log"></div>
  </div>
</div>

<div class="row">
  <div class="card">
    <h2>Typed Code (Firestore)</h2>
    <div id="hostCodeBlock" style="display:none">
      <button id="btnGen4">Generate 4-digit code</button>
      <button id="btnGen6">Generate 6-digit code</button>
      <span class="muted">Code:</span> <code id="showCode" class="small mono">—</code>
      <div class="muted">As soon as a Joiner types this code, your connection proceeds automatically.</div>
      <div style="margin-top:6px"><button id="btnCancelCode">Cancel / Clear</button></div>
    </div>
    <div id="joinerCodeBlock" style="display:none">
      <label>Enter code: <input id="inpCode" inputmode="numeric" class="mono" maxlength="6" style="width:10ch"/></label>
      <button id="btnUseCode">Use Code</button>
    </div>
  </div>

  <div class="card">
    <h2>QR (same payload)</h2>
    <div class="row">
      <div class="card">
        <h3>Host → show QR</h3>
        <button id="qrMake" disabled>Generate QR</button>
        <button id="qrTrouble" disabled>⚠ Trouble scanning? (chunk ≤4 v4)</button>
        <div id="qrWrap" style="margin-top:8px"></div>
        <div id="qrNav" class="qr-nav" style="display:none;">
          <button id="qrPrev">◀ Prev</button>
          <span id="qrIndex"></span>
          <button id="qrNext">Next ▶</button>
        </div>
      </div>
      <div class="card">
        <h3>Joiner → scan / paste</h3>
        <button id="scanStart" disabled>Start Camera Scan</button>
        <button id="scanStop" disabled>Stop</button>
        <div id="reader" style="width:320px;max-width:100%;"></div>
        <textarea id="qrPaste" placeholder="Paste scanned text…"></textarea>
        <button id="qrApply" disabled>Apply</button>
        <div id="qrProgress" class="muted" style="margin-top:6px"></div>
      </div>
    </div>
  </div>
</div>

<div class="card">
  <h2>TURN (optional)</h2>
  <div class="muted">Only used if native host/relay fails; we still prefer direct.</div>
  <label>TURN URL: <input id="turnUrl" placeholder="turn:host:port (optional)" style="width:22ch"/></label>
  <label> Username: <input id="turnUser" class="mono" style="width:18ch"/></label>
  <label> Credential: <input id="turnPass" class="mono" style="width:18ch"/></label>
</div>

<div class="card">
  <h2>Actions</h2>
  <button id="btnBeep" disabled>Beep</button>
  <button id="btnChirp" disabled>Chirp</button>
  <button id="btnPing" disabled>Ping</button>
</div>

<script type="module">
/* ---------- UI helpers ---------- */
const $ = s => document.querySelector(s);
const logEl = $('#log');
function log(...a){ const t=a.join(' '); console.log('[LOG]', t); logEl.textContent+=t+"\n"; logEl.scrollTop=logEl.scrollHeight; }
function badge(el,t,c){ el.textContent=t; el.className='status '+c; }
function sixDigits(x){ return (''+x).replace(/\D/g,'').slice(0,6).padStart(6,'0'); }
function fourDigits(x){ return (''+x).replace(/\D/g,'').slice(0,4).padStart(4,'0'); }

/* Base64url (no spread for old engines) */
function b64urlFromU8(u8){
  let bin=''; for(let i=0;i<u8.length;i++) bin+=String.fromCharCode(u8[i]);
  const b64 = btoa(bin); let out='';
  for(let i=0;i<b64.length;i++){ const ch=b64[i];
    if(ch==='+') out+='-'; else if(ch==='/') out+='_'; else if(ch==='='){} else out+=ch;
  } return out;
}
function u8FromB64url(s){
  let b64=''; for(let i=0;i<s.length;i++){ const ch=s[i];
    if(ch==='-') b64+='+'; else if(ch==='_') b64+='/'; else b64+=ch;
  } while(b64.length%4) b64+='=';
  const bin=atob(b64); const u8=new Uint8Array(bin.length);
  for(let i=0;i<bin.length;i++) u8[i]=bin.charCodeAt(i); return u8;
}

/* Simple deflate/inflate via Compression Streams (fallback to uncompressed if not supported) */
async function deflateStr(str){
  if('CompressionStream' in window){
    const cs=new CompressionStream('deflate-raw');
    const readable = new Response(new Blob([str]).stream().pipeThrough(cs)).arrayBuffer();
    return new Uint8Array(await readable);
  } else {
    // no compression, still pack
    return new TextEncoder().encode(str);
  }
}
async function inflateStr(u8){
  if('DecompressionStream' in window){
    const ds=new DecompressionStream('deflate-raw');
    const ab = await new Response(new Blob([u8]).stream().pipeThrough(ds)).arrayBuffer();
    return new TextDecoder().decode(ab);
  } else {
    // assume plain text
    return new TextDecoder().decode(u8);
  }
}

/* ---------- WebRTC ---------- */
let pc=null, dc=null, role=null;
function newPC(){
  // Build ICE server list (stun + optional turn)
  const iceServers = [{urls:'stun:stun.l.google.com:19302'}];
  const tURL=$('#turnUrl').value.trim(), tU=$('#turnUser').value.trim(), tP=$('#turnPass').value.trim();
  if(tURL){ iceServers.push(tU || tP ? {urls:tURL, username:tU, credential:tP} : {urls:tURL}); }
  const cfg = {iceServers, iceCandidatePoolSize: 2};
  const p = new RTCPeerConnection(cfg);

  p.onicegatheringstatechange = ()=>log('gathering:', p.iceGatheringState);
  p.oniceconnectionstatechange = ()=>log('ice:', p.iceConnectionState);
  p.onsignalingstatechange = ()=>log('signal:', p.signalingState);
  p.onconnectionstatechange = ()=>{
    const s=p.connectionState; badge($('#conn'),s, s==='connected'?'ok':(s==='failed'||s==='disconnected'?'bad':'warn'));
    const up = s==='connected';
    ['#btnBeep','#btnChirp','#btnPing'].forEach(id=>$(id).disabled=!up);
  };
  p.ondatachannel = e=>{ dc=e.channel; attachDC(); };
  return p;
}
function attachDC(){
  if(!dc) return;
  badge($('#dc'), dc.readyState, dc.readyState==='open'?'ok':'warn');
  dc.onopen  = ()=>badge($('#dc'),'open','ok');
  dc.onclose = ()=>badge($('#dc'),'closed','bad');
  dc.onmessage = e=>log('RX', e.data);
}
function send(m){ if(dc&&dc.readyState==='open') dc.send(m); }
$('#btnBeep').onclick = ()=>send('BEEP');
$('#btnChirp').onclick= ()=>send('CHIRP');
$('#btnPing').onclick = ()=>send('PING');

/* ---------- Firebase (Firestore) ---------- */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";
import {
  initializeFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, onSnapshot, serverTimestamp
} from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

const appFB = initializeApp({
  apiKey:"AIzaSyBZhqD0RE0miHDHhhlDZerGIsD0S5oy4Yw",
  authDomain:"ucpairing.firebaseapp.com",
  projectId:"ucpairing"
});
const auth = getAuth(appFB);
const db = initializeFirestore(appFB,{experimentalAutoDetectLongPolling:true});

let authReady=false;
signInAnonymously(auth).then(()=>{ authReady=true; log('Firebase anonymous auth OK'); })
.catch(err=>{ authReady=false; log('Firebase anon auth ERR', err.code||err.message); });

/* Firestore paths & helpers */
function pairDocRef(code){ return doc(db, 'pairs', code); }
async function reserveCode(length){
  // try up to 40 attempts to avoid collisions quickly
  for(let i=0;i<40;i++){
    const code = (''+Math.floor(Math.random()*Math.pow(10,length))).padStart(length,'0');
    const ref = pairDocRef(code);
    const snap = await getDoc(ref);
    if(!snap.exists()){
      return code;
    }
  }
  return null;
}

/* Payload packing — SAME for QR and Code */
const PAY_VER='T1'; // tiny payload v1
async function buildOfferPayload(){
  // Create/renew PC
  pc?.close(); pc=newPC();
  // DataChannel on Host
  if(role==='host'){ dc=pc.createDataChannel('x'); attachDC(); }
  // Offer
  await pc.setLocalDescription(await pc.createOffer());
  log('Host setLocalDescription(offer). Waiting for ICE gather to finish…');
  if(pc.iceGatheringState!=='complete'){
    await new Promise(r=>pc.addEventListener('icegatheringstatechange',()=>pc.iceGatheringState==='complete'&&r()));
  }
  const sdp = pc.localDescription.sdp;
  const tiny = {v:PAY_VER, r:role, t:'offer', s:sdp};
  const u8 = await deflateStr(JSON.stringify(tiny));
  const packed = b64urlFromU8(u8);
  return packed;
}
async function buildAnswerPayload(remotePacked){
  if(!pc) pc=newPC();
  const json = await inflateStr(u8FromB64url(remotePacked));
  const obj = JSON.parse(json);
  if(obj.t!=='offer'){ throw new Error('Expected offer'); }
  await pc.setRemoteDescription({type:'offer', sdp:obj.s});
  await pc.setLocalDescription(await pc.createAnswer());
  if(pc.iceGatheringState!=='complete'){
    await new Promise(r=>pc.addEventListener('icegatheringstatechange',()=>pc.iceGatheringState==='complete'&&r()));
  }
  const sdp = pc.localDescription.sdp;
  const tiny = {v:PAY_VER, r:role, t:'answer', s:sdp};
  const u8 = await deflateStr(JSON.stringify(tiny));
  return b64urlFromU8(u8);
}
async function applyAnswerPayload(packed){
  const json = await inflateStr(u8FromB64url(packed));
  const obj = JSON.parse(json);
  if(obj.t!=='answer') throw new Error('Expected answer');
  await pc.setRemoteDescription({type:'answer', sdp:obj.s});
  log('Applied answer; WebRTC should connect shortly.');
}

/* ---------- Role selection ---------- */
function setRole(r){
  role=r; badge($('#roleBadge'), r==='host'?'Host':'Joiner', 'ok');
  // enable/disable relevant UI
  $('#hostCodeBlock').style.display = (r==='host')?'block':'none';
  $('#joinerCodeBlock').style.display= (r==='join')?'block':'none';
  $('#qrMake').disabled   = (r!=='host');
  $('#qrTrouble').disabled= (r!=='host');
  $('#scanStart').disabled= (r!=='join');
  $('#scanStop').disabled = (r!=='join');
  $('#qrApply').disabled  = (r!=='join');
  log('Role set to', r);
}
$('#roleHost').onclick=()=>setRole('host');
$('#roleJoin').onclick=()=>setRole('join');

/* ---------- Code path (onSnapshot, no polling) ---------- */
let codeRef=null, codeUnsub=null, codeVal='';
async function hostGenerateCode(len){
  if(!role){ alert('Pick role first'); return; }
  if(role!=='host'){ alert('Host only'); return; }
  try{
    const packed = await buildOfferPayload();
    // try desired length
    let code = await reserveCode(len);
    if(!code && len===4){ code = await reserveCode(6); }
    if(!code){ alert('No free codes; try again.'); return; }
    codeVal = code;
    $('#showCode').textContent = code;
    codeRef = pairDocRef(code);
    // Write host payload and start listener for answer
    await setDoc(codeRef, {
      from:'host',
      offer: packed,
      ts: serverTimestamp()
    }, {merge:true});
    log(`Host wrote offer to /pairs/${code}. Waiting for answer…`);
    codeUnsub?.(); // safety
    codeUnsub = onSnapshot(codeRef, async snap=>{
      const d=snap.data()||{};
      if(d.answer){
        log('Host: got answer via code. Applying…');
        try{
          if(!pc) pc=newPC();
          await pc.setRemoteDescription({type:'answer', sdp: JSON.parse(await inflateStr(u8FromB64url(d.answer))).s});
          log('Applied answer; WebRTC should connect shortly.');
          // Optional cleanup
          // await deleteDoc(codeRef).catch(()=>{});
          codeUnsub && codeUnsub();
        }catch(e){ log('Apply answer ERR', e.message||e); }
      }
    }, err=> log('onSnapshot ERR', err.code||err.message));
  }catch(e){
    log('Host code ERR', e.code||e.message||e);
    alert('Code path failed: '+(e.code||e.message||e));
  }
}
$('#btnGen4').onclick = ()=>hostGenerateCode(4);
$('#btnGen6').onclick = ()=>hostGenerateCode(6);
$('#btnCancelCode').onclick = async ()=>{
  try{ codeUnsub && codeUnsub(); }catch{}
  codeUnsub=null;
  if(codeRef){ try{ await deleteDoc(codeRef); }catch{} }
  codeRef=null; codeVal=''; $('#showCode').textContent='—';
  log('Host: code cancelled/cleared.');
};

$('#btnUseCode').onclick = async ()=>{
  if(role!=='join'){ alert('Joiner only'); return; }
  const code = $('#inpCode').value.trim();
  if(!code) return;
  const ref = pairDocRef(code);
  try{
    const snap = await getDoc(ref);
    if(!snap.exists()){ alert('Code not found.'); return; }
    const d = snap.data()||{};
    if(!d.offer){ alert('Offer not ready yet.'); return; }
    // Build answer from that offer
    const answerPacked = await buildAnswerPayload(d.offer);
    await updateDoc(ref, { answer: answerPacked, ts: serverTimestamp() });
    log('Joiner: wrote answer. Host should connect shortly.');
    // Optionally listen for cleanup by host; not required to connect
  }catch(e){
    log('Joiner code ERR', e.code||e.message||e);
    alert('Joiner code failed: '+(e.code||e.message||e));
  }
};

/* ---------- QR path (same packed payload) ---------- */
const QR_PREFIX='QP1|'; // qr payload v1
let densePacked='';        // single payload
let chunks=[], idx=0, multi=false;

function renderQR(txt, type /* "auto"|"v4" */, label=''){
  // type "auto" lets the lib pick size; "v4" forces version 4 (33x33)
  const qr = type==='v4' ? qrcode(4, 'L') : qrcode(0, 'L');
  qr.addData(txt); qr.make();
  const svg = qr.createSvgTag(6); // scale up for readability on screen
  $('#qrWrap').innerHTML = svg + (label? `<div class="muted mono">Part ${label}</div>`:'');
}

async function makeHostQR(){
  if(role!=='host'){ alert('Host only'); return; }
  densePacked = await buildOfferPayload();
  // Keep it short: QR text = prefix + payload only
  const txt = QR_PREFIX + densePacked;
  try{
    renderQR(txt, 'auto', '');
    $('#qrTrouble').disabled=false;
    $('#qrNav').style.display='none';
    multi=false;
    log(`Dense QR shown (auto). Length: ${txt.length}`);
  }catch(e){
    log('Dense QR render failed; try chunking.', e.message||e);
    // fall back to chunking
    chunkQR();
  }
}
$('#qrMake').onclick = ()=>makeHostQR();

function chunkQR(){
  const txt = QR_PREFIX + densePacked;
  // Split for ≤4 parts v4; target <= 600 chars per part to be safe under v4 cap (~640)
  const MAX_PARTS=4, PART_LEN=600;
  chunks=[]; for(let i=0;i<txt.length;i+=PART_LEN) chunks.push(txt.slice(i,i+PART_LEN));
  if(chunks.length>MAX_PARTS){
    // if still too long, increase density a bit by removing prefix from inner chunks
    const raw = densePacked;
    chunks=[]; for(let i=0;i<raw.length;i+=PART_LEN) chunks.push(raw.slice(i,i+PART_LEN));
    if(chunks.length>MAX_PARTS){
      // ultimate fallback: more parts (still sequential with Next/Prev)
      log(`Needs ${chunks.length} parts (>4). Rendering anyway with v4.`);
    } else {
      // re-add QR_PREFIX in displayed text, but keep parts limited
      chunks = chunks.map((c,i)=> (i===0? (QR_PREFIX+c) : c));
    }
  }
  multi=true; idx=0;
  showChunk();
  $('#qrNav').style.display='flex';
}
function showChunk(){
  const total=chunks.length, part = chunks[idx];
  try{
    const label = `${idx+1}/${total}`;
    // first chunk includes prefix if not already included
    const txt = (idx===0 && !part.startsWith(QR_PREFIX)) ? (QR_PREFIX+part) : part;
    renderQR(txt, 'v4', label);
    $('#qrIndex').textContent = label;
  }catch(e){
    log('Chunk render error:', e.message||e);
  }
}
$('#qrTrouble').onclick=()=>chunkQR();
$('#qrPrev').onclick = ()=>{ if(!multi) return; idx=(idx-1+chunks.length)%chunks.length; showChunk(); };
$('#qrNext').onclick = ()=>{ if(!multi) return; idx=(idx+1)%chunks.length; showChunk(); };

/* Joiner scan / paste */
let scanner=null;
function absorb(text){
  try{
    if(text.startsWith(QR_PREFIX)){
      // simple one-shot: strip prefix, use the payload
      const payload = text.slice(QR_PREFIX.length);
      applyPacked(payload);
    }else{
      applyPacked(text);
    }
  }catch(e){ log('absorb ERR', e.message||e); }
}
async function applyPacked(packed){
  // Joiner consumes host offer and writes back answer — exactly like code path
  if(role!=='join'){ alert('Joiner only'); return; }
  try{
    const answerPacked = await buildAnswerPayload(packed);
    log('QR: built answer from offer; no Firestore needed.');
    // (Optional) show a small QR back to Host if you want QR round-trip;
    // but because we also have the typed-code route, many setups only need one-way QR.
  }catch(e){ log('applyPacked ERR', e.message||e); }
}

$('#scanStart').onclick=()=>{
  try{
    scanner = new Html5Qrcode("reader");
    scanner.start({facingMode:"environment"}, {fps:10, qrbox:240},
      txt => { absorb(txt); $('#qrProgress').textContent='Scanned.'; stopScan(); },
      _err => {}
    ).catch(err=>log('scan ERR', err));
  }catch(e){ log('scanner init ERR', e.message||e); }
};
function stopScan(){ scanner?.stop().then(()=>scanner.clear()).catch(()=>{}); scanner=null; }
$('#scanStop').onclick=()=>stopScan();
$('#qrApply').onclick=()=>{ const t=$('#qrPaste').value.trim(); if(t){ absorb(t); $('#qrPaste').value=''; } };

/* ---------- Wire up ---------- */
badge($('#conn'),'idle','warn'); badge($('#dc'),'-','warn');
log('Ready. Pick Host/Joiner. Dense QR or typed code — both carry the same payload.');
</script>
</body>
</html>