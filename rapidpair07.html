<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Rapid Pair — QR (auto-split to ≤4×V4)</title>
<style>
  body{margin:0;padding:16px;font:15px/1.4 system-ui;background:#f7f7f8;color:#222}
  h1{margin:0 0 12px;font-size:18px}
  .row{display:grid;gap:12px;grid-template-columns:1fr}
  @media(min-width:900px){.row{grid-template-columns:1fr 1fr}}
  .card{background:#fff;border:1px solid #ddd;border-radius:12px;padding:12px;margin:10px 0}
  button{padding:8px 12px;border-radius:10px;border:1px solid #ccc;background:#f5f5f5;cursor:pointer}
  button:disabled{opacity:.55;cursor:not-allowed}
  input,textarea{padding:6px;border:1px solid #ccc;border-radius:8px}
  textarea{width:100%;height:110px;font:12px monospace}
  .status{display:inline-block;padding:2px 8px;border-radius:999px;font-size:.9rem}
  .ok{background:#e8f5e9;color:#1b5e20}
  .warn{background:#fff8e1;color:#795548}
  .bad{background:#ffebee;color:#b71c1c}
  #log{font-size:.85rem;max-height:220px;overflow:auto;white-space:pre-wrap}
  #qrWrap{max-width:520px}
  .qr-nav{display:flex;gap:8px;align-items:center}
  .muted{color:#666;font-size:.9rem}
  #ver{color:#666;font-size:.8rem}
</style>
<script src="qrcode.js"></script>
<script src="pako.min.js"></script>
<script src="html5-qrcode.min.js"></script>
</head>
<body>
<h1>Rapid Pair — QR (auto-split to ≤4×V4) <span id="ver">v0.7</span></h1>

<div class="row">
  <div class="card">
    <h2>Role</h2>
    <button id="roleHost">Host</button>
    <button id="roleJoin">Joiner</button>
    <span id="roleBadge" class="status warn">no role</span>
  </div>
  <div class="card">
    <h2>Status</h2>
    <div>Peer: <span id="conn" class="status warn">idle</span> &nbsp; DataChannel: <span id="dc" class="status warn">-</span></div>
    <div id="log"></div>
  </div>
</div>

<div class="card">
  <h2>QR (offline, same LAN)</h2>
  <div class="row">
    <div class="card">
      <h3>Make & show my QR (Host/Join)</h3>
      <button id="qrMake" disabled>Create my QR</button>
      <button id="qrTrouble" style="display:none;">⚠ Trouble scanning? (force ≤4×V4)</button>
      <label style="display:block;margin-top:6px"><input type="checkbox" id="robustECC"> Robust (ECC=M)</label>
      <div id="qrWrap" style="margin-top:8px"></div>
      <div id="qrNav" class="qr-nav" style="display:none;">
        <button id="qrPrev">◀ Prev</button>
        <span id="qrIndex"></span>
        <button id="qrNext">Next ▶</button>
      </div>
    </div>
    <div class="card">
      <h3>Scan partner QR</h3>
      <button id="scanStart" disabled>Start Camera Scan</button>
      <button id="scanStop" disabled>Stop</button>
      <div id="reader" style="width:320px;max-width:100%;"></div>
      <textarea id="qrPaste" placeholder="Paste scanned text…"></textarea>
      <button id="qrApply" disabled>Apply</button>
      <div id="qrProgress" class="muted" style="margin-top:6px"></div>
    </div>
  </div>
  <div class="muted" style="margin-top:6px">Tip: We try a single dense QR first. If your camera struggles or the payload is large, click “Trouble scanning?” to force ≤4 chunked Version-4 codes. We auto-split if the dense QR overflows.</div>
</div>

<div class="card">
  <h2>Actions</h2>
  <button id="btnBeep" disabled>Beep</button>
  <button id="btnChirp" disabled>Chirp</button>
  <button id="btnPing" disabled>Ping</button>
</div>

<script type="module">
/* ========== tiny helpers ========== */
const $=s=>document.querySelector(s), logEl=$('#log');
function log(...a){const line=a.join(' '); console.log('[LOG]', line); logEl.textContent+=line+"\n"; logEl.scrollTop=logEl.scrollHeight;}
function badge(el,t,c){el.textContent=t;el.className='status '+c;}

/* base64url + compression (no spread) */
function b64url(u8){
  let bin=''; for(let i=0;i<u8.length;i++) bin+=String.fromCharCode(u8[i]);
  const b64=btoa(bin); let out='';
  for(let i=0;i<b64.length;i++){const ch=b64[i];
    if(ch==='+') out+='-'; else if(ch==='/') out+='_'; else if(ch==='='){} else out+=ch;
  } return out;
}
function unb64url(s){
  let b64=''; for(let i=0;i<s.length;i++){const ch=s[i];
    if(ch==='-') b64+='+'; else if(ch==='_') b64+='/'; else b64+=ch;
  } while(b64.length%4) b64+='=';
  const bin=atob(b64); const u8=new Uint8Array(bin.length);
  for(let i=0;i<bin.length;i++) u8[i]=bin.charCodeAt(i);
  return u8;
}
const pack = o => b64url(pako.deflate(JSON.stringify(o)));
const unpack = s => JSON.parse(pako.inflate(unb64url(s), {to:'string'}));

/* ========== role/UI ========== */
let role=null;
function setRole(r){
  role=r; badge($('#roleBadge'), r==='host'?'Host':'Joiner','ok');
  $('#qrMake').disabled=false;
  $('#scanStart').disabled=false; $('#scanStop').disabled=false; $('#qrApply').disabled=false;
  log('Role set to', r);
}
$('#roleHost').onclick=()=>setRole('host');
$('#roleJoin').onclick=()=>setRole('join');

/* ========== WebRTC (LAN-only ICE for speed) ========== */
let pc,dc;
function newPC(){
  // LAN: empty ICE servers -> host candidates only, fast on same LAN
  const cfg={iceServers:[]};
  const p=new RTCPeerConnection(cfg);
  p.onicegatheringstatechange=()=>log('gathering:',p.iceGatheringState);
  p.oniceconnectionstatechange=()=>log('ice:',p.iceConnectionState);
  p.onsignalingstatechange=()=>log('signal:',p.signalingState);
  p.onconnectionstatechange=()=>{
    const s=p.connectionState; badge($('#conn'),s, s==='connected'?'ok':(s==='failed'||s==='disconnected'?'bad':'warn'));
    const up=s==='connected'; ['#btnBeep','#btnChirp','#btnPing'].forEach(id=>$(id).disabled=!up);
  };
  p.ondatachannel=e=>{ dc=e.channel; attachDC(); };
  return p;
}
function attachDC(){
  badge($('#dc'),dc.readyState, dc.readyState==='open'?'ok':'warn');
  dc.onopen =()=>badge($('#dc'),'open','ok');
  dc.onclose=()=>badge($('#dc'),'closed','bad');
  dc.onmessage=e=>log('RX', e.data);
}
function send(m){ if(dc&&dc.readyState==='open') dc.send(m); }
$('#btnBeep').onclick=()=>send('BEEP');
$('#btnChirp').onclick=()=>send('CHIRP');
$('#btnPing').onclick =()=>send('PING');

/* utility: wait complete (cap at 1.2s) */
function waitIceCompleteOrTimeout(pc, ms=1200){
  return new Promise(res=>{
    if(pc.iceGatheringState==='complete') return res();
    const onchg=()=>{ if(pc.iceGatheringState==='complete'){ pc.removeEventListener('icegatheringstatechange',onchg); res(); } };
    pc.addEventListener('icegatheringstatechange',onchg);
    setTimeout(()=>{ pc.removeEventListener('icegatheringstatechange',onchg); res(); }, ms);
  });
}

/* ========== QR encode/render with robust fallback ========== */
const QR_PREFIX='UCP2|'; // protocol marker
let qrPacked='', qrMode='dense', qrChunks=[], qrIdx=0;

/** Try render a QR; return SVG or throw */
function renderQRStrict(text, {typeNumber=0, ecc='L', scale=4}={}){
  const q=qrcode(typeNumber, ecc);
  q.addData(text);
  q.make();
  return q.createSvgTag(scale);
}

/** Attempt dense first; if overflow -> chunk to <=4 parts at type=4 */
function showBestQR(){
  const ecc = $('#robustECC').checked ? 'M' : 'L';
  qrMode='dense';
  try{
    const svg = renderQRStrict(qrPacked, {typeNumber:0, ecc, scale:4});
    $('#qrWrap').innerHTML = svg;
    $('#qrNav').style.display='none';
    $('#qrTrouble').style.display='inline';
    log('Dense QR shown (auto type). Length:', qrPacked.length);
  }catch(e){
    if(String(e).includes('code length overflow')){
      log('Dense QR overflow. Falling back to chunked ≤4×V4…');
      forceChunkedV4();
    }else{
      log('QR encode error:', e.message||e);
    }
  }
}

/** Split s into n nearly equal parts */
function splitN(s,n){
  const size=Math.ceil(s.length/n);
  const out=[];
  for(let i=0;i<n;i++) out.push(s.slice(i*size,(i+1)*size));
  return out;
}

/** Try 2, then 3, then 4 chunks at QR type=4, ECC=M; switch UI if success */
function forceChunkedV4(){
  const ecc='M';
  for(let parts=2; parts<=4; parts++){
    const testChunks = splitN(qrPacked, parts);
    // Ensure each encodes at V4
    let ok=true;
    for(const ch of testChunks){
      try{ renderQRStrict(`${QR_PREFIX}${parts}|1|${ch}`, {typeNumber:4, ecc, scale:5}); }
      catch(err){ ok=false; break; }
    }
    if(ok){
      qrChunks = testChunks;
      qrIdx = 0;
      qrMode = 'chunk';
      $('#qrTrouble').style.display='inline';
      showChunk();
      log(`Chunked mode engaged: ${parts}×V4 (each ~${Math.ceil(qrPacked.length/parts)} chars)`);
      return;
    }
  }
  // If we got here, even 4×V4 failed; fall back to V6 chunks (still ≤4)
  log('Even 4×V4 overflow. Falling back to type=6 for chunks.');
  const parts=4;
  qrChunks = splitN(qrPacked, parts);
  qrIdx=0; qrMode='chunk';
  showChunk(6); // render with type=6
}

/** Render current chunk (default type=4; overrideType can be 6 when needed) */
function showChunk(overrideType=4){
  const ecc='M';
  const payload=`${QR_PREFIX}${qrChunks.length}|${qrIdx+1}|${qrChunks[qrIdx]}`;
  try{
    const svg = renderQRStrict(payload, {typeNumber:overrideType, ecc, scale:6});
    $('#qrWrap').innerHTML = svg;
    $('#qrIndex').textContent = `${qrIdx+1}/${qrChunks.length}`;
    $('#qrNav').style.display='flex';
  }catch(e){
    log('Chunk render error:', e.message||e);
  }
}

$('#qrPrev').onclick=()=>{ if(!qrChunks.length) return; qrIdx=(qrIdx-1+qrChunks.length)%qrChunks.length; showChunk(); };
$('#qrNext').onclick=()=>{ if(!qrChunks.length) return; qrIdx=(qrIdx+1)%qrChunks.length; showChunk(); };
$('#qrTrouble').onclick=()=>{ if(!qrPacked){ log('No payload to split.'); return; } forceChunkedV4(); };

/* ========== QR flow (Host/Join) ========== */
$('#qrMake').onclick=async()=>{
  if(!role){ alert('Pick role first'); return; }
  pc = newPC();
  if(role==='host'){ dc=pc.createDataChannel('x'); attachDC(); }

  // Build local SDP quickly (host candidates only)
  const local = (role==='host') ? await pc.createOffer() : await pc.createAnswer();
  await pc.setLocalDescription(local);
  log(role==='host'?'Host setLocalDescription(offer).':'Join setLocalDescription(answer).','Waiting ~1.2s for host candidates…');
  await waitIceCompleteOrTimeout(pc, 1200);

  // Pack minimal blob: {role, sdp:{type,sdp}}
  const blob = { role, sdp:{type:pc.localDescription.type, sdp:pc.localDescription.sdp} };
  qrPacked = pack(blob);

  // Try to show best (dense -> fallback chunk)
  showBestQR();

  // After Host shows, enable scanning so Host can read Join reply
  $('#scanStart').disabled=false; $('#scanStop').disabled=false; $('#qrApply').disabled=false;
};

/* Scanner + assembly */
let scanner=null;
let asm={total:0, got:new Set(), parts:[]};
function resetAsm(){ asm={total:0,got:new Set(),parts:[]}; $('#qrProgress').textContent=''; }
function absorb(text){
  // chunked?
  if(text.startsWith(QR_PREFIX)){
    const rest=text.slice(QR_PREFIX.length);
    const p1=rest.indexOf('|'), p2=rest.indexOf('|',p1+1);
    if(p1<0||p2<0) return;
    const total=+rest.slice(0,p1), index=+rest.slice(p1+1,p2), data=rest.slice(p2+1);
    if(!asm.total){ asm.total=total; asm.parts=Array(total).fill(''); }
    asm.got.add(index); asm.parts[index-1]=data;
    $('#qrProgress').textContent = `Got parts: ${[...asm.got].sort().join(', ')} / ${asm.total}`;
    if(asm.got.size===asm.total){
      const packed=asm.parts.join('');
      stopScanner();
      resetAsm();
      applyPacked(packed);
    }
  } else {
    // dense
    stopScanner();
    applyPacked(text);
  }
}
async function applyPacked(packed){
  try{
    const obj=unpack(packed); // { role, sdp:{type,sdp} }
    if(!pc) pc=newPC();
    if(role==='host' && obj.role==='join'){
      if(!pc.currentRemoteDescription){
        await pc.setRemoteDescription(obj.sdp);
        log('QR: Host applied Joiner answer — connecting…');
      } else log('QR: duplicate answer ignored');
    } else if(role==='join' && obj.role==='host'){
      if(!pc.currentRemoteDescription){
        await pc.setRemoteDescription(obj.sdp);
        const a=await pc.createAnswer();
        await pc.setLocalDescription(a);
        await waitIceCompleteOrTimeout(pc, 1200);
        // Prepare reply for Joiner to show back
        const reply = pack({ role:'join', sdp:{type:pc.localDescription.type, sdp:pc.localDescription.sdp} });
        qrPacked = reply;
        showBestQR();
        log('QR: Joiner reply ready — show to Host');
      } else log('QR: duplicate offer ignored');
    } else {
      alert('Role mismatch — one must be Host, the other Joiner.');
    }
  }catch(e){
    log('ERR applyPacked', e.message||e);
  }
}

function stopScanner(){
  if(scanner){
    scanner.stop().then(()=>scanner.clear()).catch(()=>{}); scanner=null;
    $('#scanStart').disabled=false; $('#scanStop').disabled=true;
    log('Scanner stopped (payload received).');
  }
}

$('#qrApply').onclick=()=>{ const t=$('#qrPaste').value.trim(); if(t){ absorb(t); $('#qrPaste').value=''; } };

$('#scanStart').onclick=()=>{ try{
  scanner=new Html5Qrcode("reader");
  $('#scanStart').disabled=true; $('#scanStop').disabled=false;
  scanner.start({facingMode:"environment"}, {fps:10, qrbox:240}, txt=>absorb(txt), _err=>{})
    .catch(err=>{ log('scan ERR', err); $('#scanStart').disabled=false; $('#scanStop').disabled=true; });
}catch(e){ log('scanner init ERR', e.message||e); } };

$('#scanStop').onclick=()=>{ stopScanner(); };

/* ========== boot ========== */
log('Ready. Pick Host/Joiner. Dense QR first; “Trouble scanning?” forces ≤4×V4.');
badge($('#conn'),'idle','warn'); badge($('#dc'),'-','warn');
</script>
</body>
</html>
